CODECHEF anuthm
```
2
2 2
1 6
```
CODECHEF chrl2
```
CHEFCHEFFFF
CHHHEEEFFCC
```
CODECHEF error
1
0101111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
CODECHEF ksum
3 4
1 3 4
3 4 1 1 0
2 3
10 2 7
0 1 1 1 1
CODECHEF passsys
1
5
1 1 1 0 0
0 1 0 1 0
1 0 1 0 1
0 1 0 1 0
0 0 0 0 0
CODECHEF stablemp

CODEFORCES 1007_C. Guess two numbers
```
10
2 4
2
2 5 1 1 2
4 1 2 3 3
```
CODEFORCES 1030_C. Vasya and Golden Ticket
```
5
73452
```

```
4
1248
```
CODEFORCES 1053_A. Vasya and Triangle
```
4 3 3
4 4 7
```
CODEFORCES 1075_B. Taxi drivers and Lyft
```
3 1
1 2 3 10
0 0 1 0

3 2
2 3 4 5 6
1 0 0 0 1

1 4
2 4 6 10 15
1 1 1 1 0
```
CODEFORCES 1096_C. Polygon for the Angle
```
1
60
```
```
4
30
45
2
178
```
```
1
0
```
```
1
180
```
```
1
90
```
CODEFORCES 1117_D. Magic Gems
```
1000000000 2
```

```
1000000000 100
```

```
1000000000 101
```

```
1000000000 102
```

```
1000000000 103
```
CODEFORCES 1143_F. U2
```
3
-1 0
0 2
1 0
```
```
5
1 0
1 -1
0 -1
-1 0
-1 -1
```
```
1
1000000000 1000000000
```
```
1000000
```
CODEFORCES 1163_E. Magical Permutation
```
2
1 2
```
```
3
1 2 3
```
```
3
1 2 4
```
```
1
20
```
```
1
1
```
```
5
1 2 3 4 5
```
```
3
1 2 3 4 6 7 5
```
```
3
1 2 3
```
```
1
10
```
```
3
1 1 1
```
```
3
2 1 3
```
```
1
4
```
CODEFORCES 1184_B1. The Doctor Meets Vader (Easy)
```
# 1. Incorrect input format

1 1
a
```

```
# 2. Incorrect output format

1 1
1 2
```

```
# 3. Incorrect algorithm

1 1
1
1 1
1
```

```
# 4. Incorrect data structures

1 1
1
1 1
1
```

```
# 5. Incorrect error handling

1 1
a
```

```
# 6. Incorrect testing

1 1
1
1 1
2
```
CODEFORCES 1202_A. You Are Given Two Binary Strings...
```
1
1010
11
```
```
1
10001
110
```
```
1
1
1010101010101
11110000
```
CODEFORCES 1219_F. Guarding warehouses
```
1
3 1 2 4 3 2 1
```
CODEFORCES 1244_A. Pens and Pencils
```
# 1. Incorrect input format

1
3 4 4 4 5
```

```
# 2. Incorrect output format

1
2
3 4 4 4 5
```

```
# 3. Incorrect calculation of the number of pens and pencils

1
7 5 4 5 8
```

```
# 4. Incorrect handling of edge cases

1
7 5 4 5 2
```

```
# 5. Incorrect use of data structures

1
7 5 4 5 8
```
CODEFORCES 1263_E. Editor
```
1
R)L)
```

```
10
(R)R(R)Ra)c
```

```
5
R)R(R)R(R)R)
```

```
12
(R)R(R)Ra)c
(R)R(R)Ra)c
```

```
1
)
```

```
4
R)R(R)R)
```

```
10
(R)R(R)Ra)c
(R)R(R)Ra)c
(R)R(R)Ra)c
(R)R(R)Ra)c
```

```
6
(R)R(R)Ra)c
(R)R(R)Ra)c
(R)R(R)Ra)c
(R)R(R)Ra)c
(R)R(R)Ra)c
```

```
10
(R)R(R)Ra)c
(R)R(R)Ra)c
(R)R(R)Ra)c
(R)R(R)Ra)c
(R)R(R)Ra)c
(R)R(R)Ra)c
(R)R(R)Ra)c
(R)R(R)Ra)c
(R)R(R)Ra)c
```
CODEFORCES 1285_A. Mezo Playing Zoma
1. ```
1
L
```
2. ```
1
R
```
3. ```
3
LRR
```
4. ```
4
LRLR
```
5. ```
5
LRLRR
```
6. ```
6
LRLRLR
```
7. ```
7
LRLRLRR
```
8. ```
8
LRLRLRLR
```
9. ```
9
LRLRLRLRR
```
10. ```
10
LRLRLRLRLR
```
CODEFORCES 1304_C. Air Conditioner
```
1
10
3 0
```

```
1
-100
1 100
```

```
2
0 100
1 100
```

```
1
0
1 100
```

```
3
100 100
100 -50 50
200 100 100
```
CODEFORCES 1328_D. Carousel
```
1
5
1 2 1 2 2
```
```
4
1 2 1 2 2
```
```
6
1 2 2 1 2 2
```
```
5
1 2 1 2 3
```
```
3
10 10 10
```
CODEFORCES 1348_D. Phoenix and Science
1
10
2
13
3
6
4
2
6
11
1
12
1
3
10
1
13
10
1
10
1
1000000000
1
1000000000
1000000000
0

CODEFORCES 1369_B. AccurateLee
5
10
0001111111
4
0101
8
11001101
10
1110000000
1
1

```
10
0101
01
0
1
```
CODEFORCES 1391_A. Suborrays
```
1
100
```
```
3
3
10
```
CODEFORCES 1413_D. Shurikens
```
1
- 1
```

```
3
+
+
- 2
- 1
- 3
```

```
4
+
+
- 2
+
- 3
+
- 1
- 4
```
CODEFORCES 1431_G. Number Deletion Game
```
5 2
3 4 1 5 2

7 3
101 108 200 1 201 109 100

5 1
1 2 3 4 5

2 1
1000000000

1 0
```
CODEFORCES 1455_D. Sequence and Swaps
```
4
2 1
2 1
1 1
1 1
5 18
81 324 218 413 324
```
CODEFORCES 1479_E. School Clubs
```
2
1 1
```

```
2
1 2
```

```
3
1 1 1
```

```
1
400000000
```

```
10
1 2 3 4 5 6 7 8 9 10
```

```
2
1 0
```

```
3
10 1 1
```

```
10
10 1 1 1 1 1 1 1 1 1
```
CODEFORCES 1506_D. Epic Transformation
```
1
4
1 1 1 1
```
```
1
1
1
```
```
1
2
1 2
```
```
3
1
1
```
```
6
2 3 2 1 3 1
```
```
3
4 3 2
```
```
3
1 1 1
```
```
5
4 5 4 5 4
```
```
1
6
1 6 1 1 4 4
```
```
3
1 1 2
```
```
1
2
2
```
```
6
2 3 2 1 3 1
```
CODEFORCES 152_C. Pocket Book
```
2 3
AAB
BAA
```

```
1 1
A
```

```
2 3
AAA
BBB
```

```
3 3
ABA
BAB
AAA
```
CODEFORCES 160_E. Buses and People
**Incorrect input format:**

```
1 1
1 10 10
1 2 1
```

**Incorrect output format:**

```
1 2 1
```

**Incorrect logic:**

```
1 1
1 10 10
1 2 1
```

**Memory leaks:**

```
n, m = map(int, input().split())
buses = []
for _ in range(n):
    buses.append(list(map(int, input().split())))
people = []
for _ in range(m):
    people.append(list(map(int, input().split())))

# Find the minimum time for each person to get to their destination.
min_times = []
for person in people:
    # Find the bus that stops at the person's starting stop and finishes before the person's desired arrival time.
    for bus in buses:
        if bus[0] <= person[0] and bus[2] <= person[1]:
            min_times.append(bus[2])

# Print the bus number for each person who can get to their destination.
for i in range(m):
    if min_times[i] != -1:
        print(min_times[i])
    else:
        print(-1)
```

**Race conditions:**

```
n, m = map(int, input().split())
buses = []
for _ in range(n):
    buses.append(list(map(int, input().split())))
people = []
for _ in range(m):
    people.append(list(map(int, input().split())))

# Find the minimum time for each person to get to their destination.
min_times = []
for person in people:
    # Find the bus that stops at the person's starting stop and finishes before the person's desired arrival time.
    for bus in buses:
        if bus[0] <= person[0] and bus[2] <= person[1]:
            min_times.append(bus[2])

# Print the bus number for each person who can get to their destination.
for i in range(m):
    if min_times[i] != -1:
        print(min_times[i])
    else:
        print(-1)

# This code is not thread-safe because it is possible for two threads to access the `min_times` list at the same time. This could lead to incorrect results.
```

**Deadlocks:**

```
n, m = map(int, input().split())
buses = []
for _ in range(n):
    buses.append(list(map(int, input().split())))
people = []
for _ in range(m):
    people.append(list(map(int, input().split())))

# Find the minimum time for each person to get to their destination.
min_times = []
for person in people:
    # Find the bus that stops at the person's starting stop and finishes before the person's desired arrival time.
    for bus in buses:
        if bus[0] <= person[0] and bus[2] <= person[1]:
            min_times.append(bus[2])

# Print the bus number for each person who can get to their destination.
for i in range(m):
    if min_times[i] != -1:
        print(min_times[i])
    else:
        print(-1)

# This code could deadlock if two threads are both trying to access the `min_times` list at the same time. This could happen if one thread is trying to add a new value to the list while another thread is trying to remove a value from the list.
```

**Buffer overflows:**

```
n, m = map(int, input().split())
buses = []
for _ in range(n):
    buses.append(list(map(int, input().split())))
people = []
for _ in range(m):
    people.append(list(map(int, input().split())))

# Find the minimum time for each person to get to their destination.
min_times = []
CODEFORCES 180_B. Divisibility Rules
```
10 10
```

```
2 3
```
CODEFORCES 203_C. Photographer
```
3 10
2 3
1 4
2 1
1 0
```
CODEFORCES 228_B. Two Tables
```
3 2
01
10
00
2 3
001
111
```

```
3 3
000
010
000
1 1
1
```

```
1 1
1
1 1
1
```

```
2 2
10
01
2 1
0
```
CODEFORCES 251_E. Tree and Table
```
3
1 3
2 3
4 3
```
CODEFORCES 277_A. Learning Languages
```
1. Incorrect input format:

```
n, m = map(int, input().split())
```

```
2. Incorrect data type:

```
n, m = input().split()
```

```
3. Incorrect logic:

```
n, m = map(int, input().split())

languages = []
for i in range(n):
    k = int(input())
    languages.append(set(map(int, input().split())))

ans = 0
for i in range(n):
    for j in range(i + 1, n):
        if not languages[i].intersection(languages[j]):
            ans += 1

print(ans)
```

```
4. Off-by-one errors:

```
n, m = map(int, input().split())

languages = []
for i in range(n):
    k = int(input())
    languages.append(set(map(int, input().split())))

ans = 0
for i in range(n):
    for j in range(i + 1, n):
        if not languages[i].intersection(languages[j]):
            ans += 1

print(ans - 1)
```

```
5. Memory errors:

```
n, m = map(int, input().split())

languages = []
for i in range(n):
    k = int(input())
    languages.append(set(map(int, input().split())))

languages = [set() for _ in range(m)]
for i in range(n):
    for l in languages[i]:
        languages[l].add(i)

ans = 0
for i in range(m):
    if len(languages[i]) == 1:
        ans += 1

print(ans)
```

```
6. Timeout errors:

```
n, m = map(int, input().split())

languages = []
for i in range(n):
    k = int(input())
    languages.append(set(map(int, input().split())))

ans = 0
for i in range(n):
    for j in range(i + 1, n):
        if not languages[i].intersection(languages[j]):
            ans += 1

print(ans)
```

```
7. Security vulnerabilities:

```
n, m = input().split()

print(n, m)
```
CODEFORCES 29_C. Mail Stamps
```
1
1 2
```
```
3
1 2
2 3
3 1
```
```
4
1 2
2 3
3 4
4 1
```
CODEFORCES 323_A. Black-and-White Cube
```
1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

34

35

36

37

38

39

40

41

42

43

44

45

46

47

48

49

50

51

52

53

54

55

56

57

58

59

60

61

62

63

64

65

66

67

68

69

70

71

72

73

74

75

76

77

78

79

80

81

82

83

84

85

86

87

88

89

90

91

92

93

94

95

96

97

98

99

100
```
CODEFORCES 347_D. Lucky Common Subsequence
```
s1 = "AB"
s2 = "CD"
virus = "A"
```

```
s1 = "AC"
s2 = "CB"
virus = "B"
```

```
s1 = "123456789"
s2 = "987654321"
virus = "123"
```

```
s1 = "AB"
s2 = "CD"
virus = "XY"
```
CODEFORCES 370_E. Summer Reading
```
6
0 0 2 1 0 0
```
```
3
1 2 3 1 2 3
```
CODEFORCES 392_B. Tower of Hanoi
```
0 1 1
1 0 1
1 1 0
3

0 2 2
1 0 100
1 2 0
3

0 2 1
1 0 100
1 2 0
5
```
CODEFORCES 415_C. Mashmokh and Numbers
```
1 1

5 2

5 3

7 2

7 1

100000 100000
```
CODEFORCES 442_A. Borya and Hanabi
**1. Incorrectly counting the number of hints.**

```
n = int(input())
cards = input().split()

colors = set()
values = set()

for card in cards:
    colors.add(card[0])
    values.add(card[1])

print(len(colors) + len(values))
```

**2. Incorrectly identifying the cards that are revealed by a hint.**

```
n = int(input())
cards = input().split()

colors = set()
values = set()

for card in cards:
    colors.add(card[0])
    values.add(card[1])

for color in colors:
    for value in values:
        if card.count(color) == 1 and card.count(value) == 1:
            print(2)
            exit()

print(3)
```

**3. Incorrectly determining the minimum number of hints.**

```
n = int(input())
cards = input().split()

colors = set()
values = set()

for card in cards:
    colors.add(card[0])
    values.add(card[1])

print(min(len(colors), len(values)))
```
CODEFORCES 464_B. Restore Cube 
```
0 0 0
0 0 1
0 0 1
0 0 1
0 1 1
0 1 1
0 1 1
1 1 1
```
CODEFORCES 488_A. Giga Tower
```
-1
-10
179
```
CODEFORCES 510_E. Fox And Dinner
```
3
3 4 5
```
```
5
2 2 2 2 2
```
```
10
2 3 4 5 6 7 8 9 10 11
```
```
24
2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
```
CODEFORCES 536_A. Tavas and Karafs
```
2 1 4
1 5 3
3 3 10
7 10 2
6 4 8
```
CODEFORCES 560_B. Gerald is into Art
```
1 2
3 4
1 1
2 2
3 5
2 3
3 3
4 4
```
CODEFORCES 586_D. Phillip and Trains
```
1
10 4
s.ZZ......
.....AAABB
.YYYYYY...
```
CODEFORCES 608_E. Marbles
```
2
N
S
```

```
3
NN
SS
```

```
3
EE
WW
```

```
4
NNW
WWS
```

```
7
NEENN
WSWSW
```

```
7
NNESWW
SWSWSW
```

```
8
NNNENW
SWSWSW
```

```
10
NNEENENW
WSWSWSW
```

```
10
NNEENENW
WSWSWSW
```

CODEFORCES 62_D. Wormhouse
```
3 3
1 2 3 1
```
```
3 3
1 3 2 1
```
```
3 3
1 3 2 3
```
```
3 3
1 2 3 3
```
```
3 3
1 2 3 2
```
```
3 3
1 3 2 1
```
```
3 3
1 3 2 1
```
```
3 3
1 2 3 1
```
```
3 3
1 2 3 1
```
```
3 3
1 2 3 1
```
```
3 3
1 2 3 1
```
```
3 3
1 2 3 1
```
```
3 3
1 2 3 1
```
CODEFORCES 656_C. Without Text
```
1
```
```
Codeforces
```
```
APRIL.1st
```
```
1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.
```
```
1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0987654321.
```
CODEFORCES 67_C. Sequence of Balls
```
1 1 1 1
youshouldnot
thoushaltnot

2 4 10 3
ab
ba

1 10 20 30
a
za
```
CODEFORCES 702_C. Cellular Network
**1. Incorrect input format**

```
1 1
1
0
```

**2. Incorrect output format**

```
3
```

**3. Incorrect algorithm**

```
1 1
1
0
```

**4. Incorrect data structures**

```
1 1
1
0
```

**5. Incorrect implementation**

```
1 1
1
0
```

**6. Incorrect test cases**

```
1 1
1
0
```
CODEFORCES 724_D. Dense Subsequence
```
3
cbabc
```
```
2
abcab
```
```
3
bcabcbaccba
```
```
1
a
```
```
100000
z
```
```
100000
a
```
```
1
z
```
```
100000
z
```
CODEFORCES 746_D. Green and Black Tea
5 1 3 2
4 3 4 0
3 2 1 1
0 2 1 0
CODEFORCES 769_D. k-Interesting Pairs Of Integers
1. Incorrect input format
```
3 2
1 3 2
```
2. Incorrect output format
```
4 0
100 100 100 100
```
3. Incorrect algorithm
```
4 1
0 3 2 1
```
4. Runtime error
```
4 0
200 100 100 100 200 200
```
5. Time limit exceeded
```
6 0
200 100 100 100 200 200
```
6. Memory limit exceeded
```
1000000000 0
```
CODEFORCES 793_D. Presents in Bankopolis
```
7 4
4
1 6 2
6 2 2
2 4 2
2 7 1


4 3
4
2 1 2
1 3 2
3 4 2
4 1 1

```
CODEFORCES 814_A. An abandoned sentiment from past
```
3 2
10 0 0
5 4

3 1
2 3 0
5

4 1
8 94 0 4
89

7 7
0 0 0 0 0 0 0
1 2 3 4 5 6 7

2 1
0 0
1
```
CODEFORCES 83_A. Magical Array
```
1
5
```

```
1
1
```

```
3
-2 -2 -2
```

```
5
-2 -2 -2 0 1
```

```
4
2 1 1 4
```

```
5
1 2 3 4 5
```

```
6
-10 -10 -10 -10 -10 -10
```

```
10
1 2 3 4 5 6 7 8 9 10
```
CODEFORCES 85_B. Embassy Queue
```
1 1 1
1 1 1
5
1 1 1 1 1

2 1 1
5 1 1
5
1 2 3 3 5

10 10 10
10 10 10
10
5 7 1 3 9 2 4 8 6 10
```
CODEFORCES 886_B. Vlad and Cafes
```
1
1

2
1 1

3
1 2 3

4
1 3 2 1

5
1 3 2 1 2

6
2 1 2 2 4 1
```
CODEFORCES 909_B. Segments
1. ```
2
```
2. ```
3
```
3. ```
4
```
4. ```
5
```
5. ```
6
```
6. ```
7
```
7. ```
8
```
8. ```
9
```
9. ```
10
```
10. ```
11
```
CODEFORCES 930_D. Game with Tokens
```
2
2 0
0 1
```

```
4
-2 0
-1 1
0 -2
1 -1
```

```
16
2 1
1 2
-1 1
0 1
0 0
1 1
2 -1
2 0
1 0
-1 -1
1 -1
2 2
0 -1
-1 0
0 2
-1 2
```
CODEFORCES 958_D2. Hyperspace Jump (hard)
```
8 2
1
5 0
1
0 1
1
0 1
2
0 6
0 1
2
0 1
1 0
2
-5 -5
4 3
2
1 1
0 1
2
1 0
1 0
```
CODEFORCES 984_D. XOR-pyramid
```
3
8 4 1
2
2 3
1 2
```
```
6
1 2 4 8 16 32
4
1 6
2 5
3 4
1 2
```
```
1
1
```
```
100000
100000
1
```
HACKEREARTH aabbaac
```
1
10 10
a
b
c
d
e
f
g
h
i
j
0
```
HACKEREARTH bob-and-candies
**Incorrect input format**

```
1 2
1
```

**Incorrect data type**

```
1 2
a
```

**Off-by-one errors**

```
3 7
1 3 4
```

**Incorrect logic**

```
3 7
1 3 4
```

**Infinite loops**

```
1 1
1
```

**Memory leaks**

```
10000000 1
1
```

**Security vulnerabilities**

```
1 1
1
```

**Incorrect error handling**

```
1 1
a
```

**Undocumented features**

```
1 1
1
```
HACKEREARTH crushing-violence

HACKEREARTH free-drives-1
1
1
2
3
4
5
6
7
8
9
10
HACKEREARTH jp-and-rotations
4 4
2 1 3 4
3 4 2 1
R 1
L 2
L 1
L 5
HACKEREARTH milly-and-magical-array-3
```
2
2 1
1 1
3 1
1 1 2
```
HACKEREARTH pairs-5
1
5
2
2
6
5
3
3
5
4
4
4
HACKEREARTH restaurant-renting-oven-2
```
1

3 5
0 1 10
1 2 20
2 3 30
2 1 1 1 1
```
HACKEREARTH sorting-the-string
1
d9
0
HACKEREARTH toy
1
40

3
7 3 6 12 18
ATCODER p02572 AtCoder Beginner Contest 177 - Sum of product of pairs
```
3
1 2 3
```

```
4
141421356 17320508 22360679 244949
```

```
8
1 2 3 4 5 6 7 8
```
ATCODER p02703 AtCoder Beginner Contest 164 - Two Currencies
```
2 1 1
1 2 1 2
1 1
1 2
```
```
3 2 1
1 2 1 2
1 3 2 4
1 11
1 2
2 5
```
```
4 4 1
1 2 1 5
1 3 4 4
2 4 2 2
3 4 1 1
3 1
3 1
5 2
6 4
```
```
6 5 1
1 2 1 1
1 3 2 1
2 4 5 1
3 5 11 1
1 6 50 1
1 10000
1 3000
1 700
1 100
1 1
100 1
```
```
4 6 1000000000
1 2 50 1
1 3 50 5
1 4 50 7
2 3 50 2
2 4 50 4
3 4 50 3
10 2
4 4
5 5
7 7
```
```
2 1 0
1 2 1 1
1 1000000000
1 1
```
ATCODER p02832 AtCoder Beginner Contest 148 - Brick Break
```
3
2 1 2

3
2 2 2

10
3 1 4 1 5 9 2 6 5 3

1
1
```
ATCODER p02969 AtCoder Beginner Contest 134 - Dodecagon
1. 0
2. -1
3. 3.14159
4. 1.5
5. 101
ATCODER p03105 AtCoder Beginner Contest 120 - Favorite Sound
```
2 11 4
```

```
3 9 5
```

```
100 1 10
```
ATCODER p03252 AtCoder Beginner Contest 110 - String Transformation
```
azzel
apple

chokudai
redcoder

abcdefghijklmnopqrstuvwxyz
ibyhqfrekavclxjstdwgpzmonu
```
ATCODER p03405 AtCoder Regular Contest 093 - Bichrome Spanning Tree
```
# coding: utf-8

N, M = map(int, input().split())
X = int(input())

G = [[] for _ in range(N)]
for _ in range(M):
    u, v, w = map(int, input().split())
    u -= 1
    v -= 1
    G[u].append((v, w))
    G[v].append((u, w))


def dfs(u, p, w):
    for v, w in G[u]:
        if v == p:
            continue
        if w < X:
            return dfs(v, u, w)
    return w


ans = 0
for i in range(N):
    for j in range(N):
        if i != j:
            w = dfs(i, j, X)
            ans += w

print(ans % (10 ** 9 + 7))
```
ATCODER p03568 CODE FESTIVAL 2017 qual C - Similar Arrays
1. ```
N = int(input())
A = list(map(int, input().split()))

count = 0
for a in A:
    if a % 2 == 0:
        count += 1

print(count)
```

2. ```
N = int(input())
A = list(map(int, input().split()))

count = 0
for a in A:
    if a % 2 == 0:
        count += 1

print(count)
```

3. ```
N = int(input())
A = list(map(int, input().split()))

count = 0
for a in A:
    if a % 2 == 0:
        count += 1

print(count)
```

4. ```
N = int(input())
A = list(map(int, input().split()))

count = 0
for a in A:
    if a % 2 == 0:
        count += 1

print(count)
```

5. ```
N = int(input())
A = list(map(int, input().split()))

count = 0
for a in A:
    if a % 2 == 0:
        count += 1

print(count)
```
ATCODER p03723 AtCoder Grand Contest 014 - Cookie Exchanges
14 14 14
ATCODER p03886 CODE FESTIVAL 2016 Grand Final(Parallel) - 90 and 270
3
90
90
90
ATCODER p04044 AtCoder Beginner Contest 042 - Iroha Loves Strings (ABC Edition)
```
# 1. The input format is not specified clearly.

1 3
dxx

# 2. The output format is not specified clearly.

axxcxxdxx

# 3. The problem statement is not clear.

# 4. The code is not well-structured.

# 5. The code is not efficient.

# 6. The code contains bugs.
```
AIZU p00125 Day Count
```
2006 9 1 2006 9 2
2006 9 2 2006 11 11
2004 1 1 2005 1 1
2000 1 1 2006 1 1
2000 1 1 2101 1 1
-1 -1 -1 -1 -1 -1
```
AIZU p00258 Beat Panel

AIZU p00445 JOI and IOI
```
JOIJOI
JOIOIOIOI
JOIOIJOINXNXJIOIOIOJ
JOI
```
AIZU p00636 The Last Dungeon
1. ```
2
1 1
3 3
```
2. ```
2
0 0
1 1
```
3. ```
4
1.0 0.5
1.0 2.5
3.0 1.5
3.0 3.5
```
4. ```
1
2.0 2.0
```
5. ```
0
```
AIZU p00779 Don't Cross the Circles!
```
# Problem: Don't Cross the Circles!

```

```
5 3
0 0 1000
1399 1331 931
0 1331 500
1398 0 400
2000 360 340
450 950 1600 380
450 950 1399 1331
450 950 450 2000
1 2
50 50 50
0 10 100 90
0 10 50 50
2 2
50 50 50
100 50 50
40 50 110 50
40 50 0 0
4 1
25 100 26
75 100 26
50 40 40
50 160 40
50 81 50 119
6 1
100 50 40
0 50 40
50 0 48
50 50 3
55 55 4
55 105 48
50 55 55 50
20 6
270 180 50
360 170 50
0 0 50
10 0 10
0 90 50
0 180 50
90 180 50
180 180 50
205 90 50
180 0 50
65 0 20
75 30 16
90 78 36
105 30 16
115 0 20
128 48 15
128 100 15
280 0 30
330 0 30
305 65 42
0 20 10 20
0 20 10 0
50 30 133 0
50 30 133 30
90 40 305 20
90 40 240 30
16 2
0 0 50
0 90 50
0 180 50
90 180 50
180 180 50
205 90 50
180 0 50
65 0 20
115 0 20
90 0 15
280 0 30
330 0 30
305 65 42
75 40 16
90 88 36
105 40 16
128 35 250 30
90 50 305 20
0 0

```

```
0 0
0 1
1 0
1 1
```
AIZU p00910 Let There Be Light
12 5 4
0 10 0 1
1 5 0 2
1 4 0 2
0 0 0 2
10 0 0 1
3 -1 0 2
5 -1 0 2
10 10 0 15
0 -10 0 1
10 -10 0 1
-10 -10 0 1
10 10 0 1
0 10 0 240
10 0 0 200
10 -2 0 52
-10 0 0 100
1 1 0 2
0 0 0
12 5 4
0 10 0 1
1 5 0 2
1 4 0 2
0 0 0 2
10 0 0 1
3 -1 0 2
5 -1 0 2
10 10 0 15
0 -10 0 1
10 -10 0 1
-10 -10 0 1
10 10 0 1
0 10 0 260
10 0 0 200
10 -2 0 52
-10 0 0 100
1 1 0 2
0 0 0
5 1 3
1 2 0 2
-1 8 -1 8
-2 -3 5 6
-2 1 3 3
-4 2 3 5
1 1 2 7
0 0 0
5 1 2
1 2 0 2
-1 8 -1 8
-2 -3 5 6
-2 1 3 3
-4 2 3 5
1 1 2 7
0 0 0
0 0 0
AIZU p01044 Puzzle and Hexagons
```
3 3
RGR
RBP
YEB
1
1 1

3 3
RGR
RBP
YEB
1
1 2

4 5
BYYGG
RRRRR
RRBRR
YYGGB
2
3 1
3 1

4 4
BEEP
ERYY
BBRP
RBYP
1
1 2

4 4
YRRR
RRYR
YYRR
RRYY
4
0 0
0 1
1 0
1 1
```
AIZU p01177 Entangled Tree
```
0 0 0
```
AIZU p01314 Sum of Consecutive Integers
9
500
0
AIZU p01482 Memory Leak
```
100
A=malloc(10)
B=clone(A)
free(A)
```
AIZU p01643 Avant-garde Art
```
8 0
7 4 6 2 8 3 1 5
```

```
8 1
7 4 6 2 8 3 1 5
```

```
8 0
5 6 7 8 1 2 3 4
```
AIZU p01795 ICPC Teams
```
2 2
1 2 0
3 4 1
```
AIZU p01929 Room Assignment
```
2
2 1
3
3 1 2
10
2 1 1 1 1 1 1 1 1 1
8
2 1 4 3 3 7 6 6
25
2 3 2 5 4 5 8 7 8 11 10 13 12 15 14 17 16 19 18 21 20 23 22 25 24
10
2 1 4 3 6 5 8 7 10 9
0
```
AIZU p02067 AIGo
5 .WB..
AIZU p02209 Are Cards Snacks?
5 9
8 6 9 1 2
AIZU p02363 All Pairs Shortest Path
```
# 1. Using the wrong data type for the graph

```python
def floyd_warshall(graph):
  """
  Finds the shortest paths between all pairs of vertices in a directed graph.

  Parameters:
    graph: A list of edges, where each edge is a tuple of (source, target, weight).

  Returns:
    A matrix of distances, where each element is the shortest distance from one vertex to another.
  """

  # Initialize the distance matrix
  dist = [[float("inf")] * len(graph) for _ in range(len(graph))]
  for i in range(len(graph)):
    dist[i][i] = 0

  # Iterate over all pairs of vertices
  for k in range(len(graph)):
    for i in range(len(graph)):
      for j in range(len(graph)):
        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])

  return dist


def main():
  # Create a graph with a negative cycle
  graph = [
    (0, 1, 1),
    (0, 2, -5),
    (1, 2, 2),
    (1, 3, 4),
    (2, 3, 1),
    (3, 2, -7)
  ]

  # Try to find the shortest paths between all pairs of vertices
  try:
    dist = floyd_warshall(graph)
  except ValueError:
    # The Floyd-Warshall algorithm failed because the graph contained a negative cycle
    print("NEGATIVE CYCLE")
  else:
    # Print the shortest distances between all pairs of vertices
    for row in dist:
      print(*row)


if __name__ == "__main__":
  main()
```

```
# 2. Using the wrong data type for the distances

```python
def floyd_warshall(graph):
  """
  Finds the shortest paths between all pairs of vertices in a directed graph.

  Parameters:
    graph: A list of edges, where each edge is a tuple of (source, target, weight).

  Returns:
    A matrix of distances, where each element is the shortest distance from one vertex to another.
  """

  # Initialize the distance matrix
  dist = [[float("inf")] * len(graph) for _ in range(len(graph))]
  for i in range(len(graph)):
    dist[i][i] = 0

  # Iterate over all pairs of vertices
  for k in range(len(graph)):
    for i in range(len(graph)):
      for j in range(len(graph)):
        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])

  return dist


def main():
  # Create a graph with a negative cycle
  graph = [
    (0, 1, 1),
    (0, 2, -5),
    (1, 2, 2),
    (1, 3, 4),
    (2, 3, 1),
    (3, 2, -7)
  ]

  # Try to find the shortest paths between all pairs of vertices
  try:
    dist = floyd_warshall(graph)
  except ValueError:
    # The Floyd-Warshall algorithm failed because the graph contained a negative cycle
    print("NEGATIVE CYCLE")
  else:
    # Print the shortest distances between all pairs of vertices
    for row in dist:
      print(*row)


if __name__ == "__main__":
  main()
```

```
# 3. Using the wrong algorithm

```python
def floyd_warshall(graph):
  """
  Finds the shortest paths between all pairs of vertices in a directed graph.

  Parameters:
    graph: A list of edges, where each edge is a tuple of (source, target, weight).

  Returns:
    A matrix of distances, where each element is the shortest distance from one vertex to another.
  """

  # Initialize the distance matrix
  dist = [[float("inf")] * len(graph) for 