CODECHEF bitcj5
```
1
3 2
1 2 3
```
CODECHEF coins
```
12
2
```
CODECHEF galactik
100001 100000
1 2
2 3
1 3
4 5
5 6
4 6
1
3
5
2
4
6
-1
CODECHEF lucky10
```
4
4
7
435
479
7
8
1675475
9756417
```
CODECHEF promo
```
1
10 5 5
```
CODECHEF tech04
1
aaba aaab
CODEFORCES 1012_A. Photo of The Sky
```
1
1000000000
```
```
3
1 1 1
```
```
6
3 4 5 6 7 8
```
```
5
1 2 3 4 5
```
CODEFORCES 1037_A. Packets
```
1
2
3
4
5
6
7
8
9
10
100
1000
10000
100000
1000000
10000000
100000000
```
CODEFORCES 105_B. Dark Assembly
```
1 1 1
100 100
```
```
1 3 20
20 20
```
```
5 6 100
11 80
14 90
23 70
80 30
153 70
```
```
5 3 100
11 80
14 90
23 70
80 30
153 70
```
```
10 10 100
1 10
2 10
3 10
4 10
5 10
6 10
7 10
8 10
9 10
10 10
```
```
2 1 30
10 10
```
```
10 10 100
10 100
20 100
30 100
40 100
50 100
60 100
70 100
80 100
90 100
100 100
```
```
10 10 100
10 10
20 10
30 10
40 10
50 10
60 10
70 10
80 10
90 10
100 10
```
CODEFORCES 1081_C. Colorful Bricks
```
1 2 0
3 3 0
3 2 1
```
CODEFORCES 1100_C. NN and the Optical Illusion
3 1
6 1
100 100
CODEFORCES 1129_A1. Toy Train (Simplified)
```
3 2
1 2
2 3
```
```
3 3
1 2
3 1
2 3
```
```
5 6
2 4
5 1
2 3
3 4
4 1
5 3
3 5
```
CODEFORCES 1149_A. Prefix Sum Primes
1. ```
5
1 2 1 2 1
```

2. ```
9
1 1 2 1 1 1 2 1 1
```

3. ```
1
1
```

4. ```
2
1 2
```

5. ```
5
3 2 1 2 1
```

6. ```
10
1 1 2 1 1 1 2 1 1
```

7. ```
10
1 1 2 2 2 1 1 1 1
```

8. ```
10
2 1 2 1 1 2 1 1 2
```

9. ```
10
2 2 2 2 1 1 1 1 1
```
CODEFORCES 1170_A. Three Integers Again
```
1
1 1
```

```
3
2 2
1000000000 1000000000
2000000000 2000000000
```

```
10
1000000000 1000000000
1000000000 1000000000
1000000000 1000000000
1000000000 1000000000
1000000000 1000000000
1000000000 1000000000
1000000000 1000000000
1000000000 1000000000
1000000000 1000000000
1000000000 1000000000
```
CODEFORCES 1188_E. Problem from Red Panda
```
2
0 1
```

```
3
0 1 2
```

```
5
0 0 1 2 3
```

```
3
2 2 8
```

```
10
1 1 1 1 1 1 1 1 1 1
```
CODEFORCES 1207_G. Indie Album
```
10
1 c
1 d
1 e
1 f
1 g
1 h
1 i
1 j
1 k
10
1 c
1 d
1 e
1 f
1 g
1 h
1 i
1 j
1 k
10
```
CODEFORCES 1225_G. To Make 1
```
2 2
1 1
```

```
4 3
7 8 13 23
```

```
3 4
1 2 3
```

```
2 2
5 5
```

```
4 3
1 2 3 4
```

```
4 2
1 2 3 4
```

```
4 2
1 2 4 8
```
CODEFORCES 124_C. Prime Permutation
```
abc
abcd
xxxyxxx
```
CODEFORCES 1269_A. Equation
1
512
CODEFORCES 1291_A. Even But Not Even
```
5
4
1227
1
0
6
177013
24
222373204424185217171912
2
2222
2
333321
3
222321
```
CODEFORCES 1311_B. WeirdSort
1. ```
1
3 2
3 2 1
1 2
```
2. ```
1
4 2
4 1 2 3
3 2
```
3. ```
1
5 1
1 2 3 4 5
1
```
4. ```
1
4 2
2 1 4 3
1 3
```
5. ```
1
5 2
2 1 2 3 3
1 4
```
CODEFORCES 1333_F. Kate and imperfection
2
3
5
10
100
CODEFORCES 1354_C1. Simple Polygon Embedding
```
3
2
4
200
```
CODEFORCES 1374_A. Required Remainder
```
1
7 5 12345
```

```
5
7 5 12345
5 0 4
10 5 15
17 8 54321
499999993 9 1000000000
10 5 187
2 0 999999999
```
CODEFORCES 1397_B. Power Sequence
```
3
1 3 2
```

```
3
1000000000 1000000000 1000000000
```

```
1
2000000000
```

```
3
1000000000 999999998 1000000000
```

```
2
1000000000 1000000000
```

```
5
1000000000 1000000000 1000000000 1000000000 1000000000
```
CODEFORCES 1420_C2. Pokémon Army (hard version)
1
3 1
1 3 2
1 2
1 2
1 2
CODEFORCES 1439_B. Graph Subset Problem
```
1
5 9 4
1 2
1 3
1 4
1 5
2 3
2 4
2 5
3 4
3 5
```

```
2
4 1 2 3 
1 10
4 5 4
1 2
2 3
3 4
4 1
1 3
```

```
3
5 9 4
1 2
1 3
1 4
1 5
2 3
2 4
2 5
3 4
3 5
10 15 3
1 2
2 3
3 4
4 5
5 1
1 7
2 8
3 9
4 10
5 6
7 10
10 8
8 6
6 9
9 7
4 5 4
1 2
2 3
3 4
4 1
1 3
```
CODEFORCES 1466_B. Last minute enhancements
1
6
1 2 2 2 5 6
2
4 4
6
1 1 3 4 4 5
1
1
6
1 1 1 2 2 2
CODEFORCES 1490_C. Sum of Cubes
1. **Incorrect input type**
```
1
a
```

2. **Incorrect output type**
```
1
1
```

3. **Incorrect use of 64-bit integer type**
```
1
101234567890123456789
```

4. **Incorrect algorithm**
```
1
1000000000000000000
```

5. **Incorrect error handling**
```
1
-1
```

6. **Incorrect testing**
```
1
1000000000000000000
```

7. **Incorrect documentation**
```
1
1000000000000000000
```
CODEFORCES 1512_F. Education
```
1
5 900000000
20 40 20 10 5
10 5 3 1 0
```
CODEFORCES 153_D. Date Change
**Incorrect input format**

```
10.1.2012
12
```

**Invalid date**

```
10.13.2021
12
```

**Negative shift**

```
10.02.2010
-41
```

**Overflow**

```
10.02.2010
1001
```

**Incorrect handling of leap years**

```
29.02.2016
1
```

**Incorrect handling of time zones and daylight saving time**

```
01.01.2020
12
```
CODEFORCES 167_B. Wizards and Huge Prize
```
3 1 0
10 20 30
-1 -1 2

```
CODEFORCES 188_C. LCM
```
10 42
123 41
-10 42
0 42
```
CODEFORCES 209_A. Multicolored Marbles
1. `0`
2. `1000000008`
3. `1000000009`
4. `-1`
5. `"abc"`
CODEFORCES 234_E. Champions' League
8
1 3 1 7
Barcelona 158
Milan 90
Spartak 46
Anderlecht 48
Celtic 32
Benfica 87
Zenit 79
Malaga 16
CODEFORCES 25_C. Roads in Berland
```
2
0 5
5 0
1
1 2 3

```
```
3
0 4 5
4 0 9
5 9 0
2
2 3 8
1 2 1
```
```
4
0 4 5
4 0 9
5 9 0
2
1 2 1
2 3 8
```
CODEFORCES 283_C. Coin Troubles
**Incorrect input format**

```
4 2 17
3 1 2 5
4 2
3 4
```

**Incorrect variable type**

```
4 2 17
3 1 2 5
4 2
3 4
```

**Incorrect calculation**

```
4 2 17
3 1 2 5
4 2
3 4
```

**Incorrect output format**

```
4 2 17
3 1 2 5
4 2
3 4
```

**Other bugs**

```
4 2 17
3 1 2 5
4 2
3 4
```
CODEFORCES 306_B. Optimizer
```
10 4
3 3
3 1
4 1
9 2
```
```
1 2
```
```
10 4
3 3
3 1
4 1
9 2
```
```
2
2 3 
```
```
1 1
```
```
0
```
CODEFORCES 331_D1. Escaping on Beaveractor
```
# 331_D1. Escaping on Beaveractor

## Problem spec

Don't put up with what you're sick of! The Smart Beaver decided to escape from the campus of Beaver Science Academy (BSA). BSA is a b × b square on a plane. Each point x, y (0 ≤ x, y ≤ b) belongs to BSA. To make the path quick and funny, the Beaver constructed a Beaveractor, an effective and comfortable types of transport.

The campus obeys traffic rules: there are n arrows, parallel to the coordinate axes. The arrows do not intersect and do not touch each other. When the Beaveractor reaches some arrow, it turns in the arrow's direction and moves on until it either reaches the next arrow or gets outside the campus. The Beaveractor covers exactly one unit of space per one unit of time. You can assume that there are no obstacles to the Beaveractor.

The BSA scientists want to transport the brand new Beaveractor to the "Academic Tractor" research institute and send the Smart Beaver to do his postgraduate studies and sharpen pencils. They have q plans, representing the Beaveractor's initial position (xi, yi), the initial motion vector wi and the time ti that have passed after the escape started.

Your task is for each of the q plans to determine the Smart Beaver's position after the given time.

## Input

The first line contains two integers: the number of traffic rules n and the size of the campus b, 0 ≤ n, 1 ≤ b. Next n lines contain the rules. Each line of the rules contains four space-separated integers x0, y0, x1, y1 — the beginning and the end of the arrow. It is guaranteed that all arrows are parallel to the coordinate axes and have no common points. All arrows are located inside the campus, that is, 0 ≤ x0, y0, x1, y1 ≤ b holds.

Next line contains integer q — the number of plans the scientists have, 1 ≤ q ≤ 105. The i-th plan is represented by two integers, xi, yi are the Beaveractor's coordinates at the initial time, 0 ≤ xi, yi ≤ b, character wi, that takes value U, D, L, R and sets the initial direction up, down, to the left or to the right correspondingly (the Y axis is directed upwards), and ti — the time passed after the escape started, 0 ≤ ti ≤ 1015.

## Output

Print q lines. Each line should contain two integers — the Beaveractor's coordinates at the final moment of time for each plan. If the Smart Beaver manages to leave the campus in time ti, print the coordinates of the last point in the campus he visited.

## Examples

```
Input

3 3
0 0 0 1
0 2 2 2
3 3 2 3
12
0 0 L 0
0 0 L 1
0 0 L 2
0 0 L 3
0 0 L 4
0 0 L 5
0 0 L 6
2 0 U 2
2 0 U 3
3 0 U 5
1 3 D 2
1 3 R 2


Output

0 0
0 1
0 2
1 2
2 2
3 2
3 2
2 2
3 2
1 3
2 2
1 3
```

## Key potential problems

1. **Incorrect input format.** The input format for this problem is very specific, and it's easy to make a mistake when writing it. For example, you might forget to include a space between two numbers, or you might use the wrong characters to represent the directions. If you make a mistake in the input format, the program will not be able to run correctly.
2. **Incorrect logic.** The logic for this problem is fairly complex, and it's easy to make a mistake when writing it. For example, you might forget to check for certain conditions, or you might use the wrong variables. If you make a mistake in the logic, the program will not be able to produce the correct output.
3. **Incorrect implementation.** Even if you get the input format and logic correct, you still need to implement the program correctly. This means using the right data structures and algorithms, and writing your code in a clear and efficient way. If you make a mistake in the implementation, the program will not be able to run correctly.

## Program inputs

```
3 3
0 0 0 1
0 2
CODEFORCES 354_A. Vasya and Robot
**Incorrect data type:**

```
3 4 4 19 1
42 3 99
```

**Off-by-one error:**

```
3 4 4 19 1
42 3 99
```

**Incorrect logic:**

```
3 4 4 19 1
42 3 99
```

**Memory leak:**

```
3 4 4 19 1
42 3 99
```

**Security vulnerability:**

```
3 4 4 19 1
42 3 99
```
CODEFORCES 378_B. Semifinals
```
4
9840 9920
9860 9980
9930 10020
10040 10090
```

```
4
9900 9850
9940 9930
10000 10020
10060 10110
```
CODEFORCES 39_D. Cubical Planet
1. Incorrect input format
```
0 0 0
1 1
```
2. Incorrect output format
```
0 0 0
0 1 0
YES
```
3. Off-by-one errors
```
0 0 0
1 1 1
YES
```
4. Incorrect logic
```
0 0 0
1 0 0
YES
```
5. Runtime errors
```
0 0 0
0 0 0
```
CODEFORCES 424_E. Colored Jenga
```
2
RG
```
```
5
RGB
GRG
BBB
GGR
BRG
```
```
6
RGB
GRG
BBB
GGR
BRG
BRB
```
```
3
RRR
GRG
```
```
4
RRG
GGB
BRG
```
```
1
R
```
```
6
RRB
GRR
BRB
GRG
BRG
BBB
```
```
5
BBG
BRR
RGB
GRB
```
CODEFORCES 449_C. Jzzhu and Apples
1. 1
2. 2
3. 3
4. 4
5. 5
6. 6
7. 7
8. 8
9. 9
10. 10
11. 11
12. 12
13. 13
14. 14
15. 15
16. 16
17. 17
18. 18
19. 19
20. 20
CODEFORCES 470_B. Hexakosioihexekontahexaphobia
```
16660
123098
1606061
16666
```
CODEFORCES 493_E. Vasya and Polynomial
```
2 2 2
```
```
2 3 3
```
```
100 100 100
```
```
1000000000 1000000000 1000000000
```
```
1018 1018 1018
```
CODEFORCES 518_D. Ilya and Escalator
```
1 0.50 1
1 0.50 4
4 0.20 2
10 0.30 10
100 0.50 100
```
CODEFORCES 544_D. Destroying Roads
```
5 4
1 2
2 3
3 4
4 5
1 3 2
3 5 2

5 4
1 2
2 3
3 4
4 5
1 3 2
2 4 2

5 4
1 2
2 3
3 4
4 5
1 3 2
3 5 1
```
CODEFORCES 571_A. Lengthening Sticks
### Incorrect input format
```
1 1 1 1
```

### Incorrect output format
```
1
```

### Undefined behavior
```
#include <stdio.h>

int main() {
    int a, b, c, l;
    scanf(" %d %d %d %d ", &a, &b, &c, &l);
    printf(" %d ", a + b + c - l);
    return 0;
}
```

### Memory leaks
```
#include <stdio.h>

int main() {
    int a, b, c, l;
    scanf(" %d %d %d %d ", &a, &b, &c, &l);
    int *p = malloc(sizeof(int));
    *p = a + b + c - l;
    printf(" %d ", *p);
    free(p);
    return 0;
}
```

### Race conditions
```
#include <stdio.h>
#include <pthread.h>

int a, b, c, l;
int count = 0;

void *inc_a(void *arg) {
    a++;
    count++;
    return NULL;
}

void *inc_b(void *arg) {
    b++;
    count++;
    return NULL;
}

void *inc_c(void *arg) {
    c++;
    count++;
    return NULL;
}

int main() {
    pthread_t t1, t2, t3;
    pthread_create(&t1, NULL, inc_a, NULL);
    pthread_create(&t2, NULL, inc_b, NULL);
    pthread_create(&t3, NULL, inc_c, NULL);
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
    pthread_join(t3, NULL);
    printf(" %d ", count);
    return 0;
}
```

### Deadlocks
```
#include <stdio.h>
#include <pthread.h>

int a, b, c, l;
int count = 0;

void *inc_a(void *arg) {
    pthread_mutex_lock(&mutex_a);
    a++;
    count++;
    pthread_mutex_unlock(&mutex_b);
    return NULL;
}

void *inc_b(void *arg) {
    pthread_mutex_lock(&mutex_b);
    b++;
    count++;
    pthread_mutex_unlock(&mutex_a);
    return NULL;
}

int main() {
    pthread_t t1, t2;
    pthread_mutex_init(&mutex_a, NULL);
    pthread_mutex_init(&mutex_b, NULL);
    pthread_create(&t1, NULL, inc_a, NULL);
    pthread_create(&t2, NULL, inc_b, NULL);
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
    printf(" %d ", count);
    return 0;
}
```

### Buffer overflows
```
#include <stdio.h>

int main() {
    char str[10];
    scanf(" %s ", str);
    printf(" %s ", str);
    return 0;
}
```

### Integer overflows
```
#include <stdio.h>

int main() {
    int a = 2147483647;
    int b = a + 1;
    printf(" %d ", b);
    return 0;
}
```

### Floating-point errors
```
#include <stdio.h>

int main() {
    float a = 1.0;
    float b = 0.0;
    float c = a / b;
    printf(" %f ", c);
    return 0;
}
```

### Security vulnerabilities
```
#include <stdio.h>

int main() {
    char buf[100];
    scanf(" %s ", buf);
    printf(" %s ", buf);
    return 0;
}
```
CODEFORCES 592_D. Super M
```
1 1

2 1
1 2
2

4 4
1 2
2 3
3 4
1
```
CODEFORCES 614_B. Gena's Code
**1. Incorrect input format**

```
n = int(input())
a = list(map(int, input().split()))
```

This code will incorrectly parse the input format and read the number of countries as a string.

**2. Incorrect calculation of the product**

```
product = 1
for i in range(n):
    product *= a[i]
```

This code will incorrectly calculate the product by multiplying the numbers in the wrong order.

**3. Overflow**

```
product = 1
for i in range(n):
    product *= a[i]
print(product)
```

This code will overflow if the product of the number of tanks from each country is very large.

**4. Undefined behavior**

```
n = int(input())
a = list(map(int, input().split()))
product = 1
for i in range(n):
    product *= a[i]
print(product)
```

This code will incorrectly produce output if the number of tanks from a country is not beautiful.

**5. Security vulnerabilities**

The program below is vulnerable to a variety of security vulnerabilities, such as buffer overflows, format string vulnerabilities, and SQL injection attacks.

```
import sys

def main():
    n = int(input())
    a = sys.stdin.readline().strip()
    print(a)

if __name__ == "__main__":
    main()
```
CODEFORCES 633_G. Yash And Trees
```
# -*- coding: utf-8 -*-
"""
Created on Tue Jul 27 15:17:57 2021

@author: xiaoshuang
"""

"""
Problem: Yash And Trees

Key potential problems:
1. Incorrect implementation of the segment tree.
2. Incorrect use of the segment tree.
3. Incorrect handling of overflow.
4. Incorrect handling of duplicate elements.
5. Incorrect handling of boundary conditions.

Test cases:

1. Test case for incorrect implementation of the segment tree.
2. Test case for incorrect use of the segment tree.
3. Test case for incorrect handling of overflow.
4. Test case for incorrect handling of duplicate elements.
5. Test case for incorrect handling of boundary conditions.
"""

"""
Test case 1: Incorrect implementation of the segment tree.

The segment tree is implemented incorrectly, so it is not able to answer queries correctly.
"""

def segment_tree(n, a):
    """
    Builds a segment tree for the given array.

    Args:
        n (int): The number of elements in the array.
        a (list): The array of values.

    Returns:
        list: The segment tree.
    """

    tree = [0] * (2 * n)
    for i in range(n):
        tree[i + n] = a[i]
    for i in range(n - 1, 0, -1):
        tree[i] = tree[i * 2] + tree[i * 2 + 1]
    return tree

def query(tree, l, r):
    """
    Returns the sum of the elements in the given range of the segment tree.

    Args:
        tree (list): The segment tree.
        l (int): The left index of the range.
        r (int): The right index of the range.

    Returns:
        int: The sum of the elements in the given range.
    """

    if l > r:
        return 0
    return tree[l + r]

def update(tree, i, v):
    """
    Updates the value of the element at the given index in the segment tree.

    Args:
        tree (list): The segment tree.
        i (int): The index of the element to be updated.
        v (int): The new value of the element.
    """

    i += n
    tree[i] = v
    while i > 1:
        i //= 2
        tree[i] = tree[i * 2] + tree[i * 2 + 1]

n, m = map(int, input().split())
a = list(map(int, input().split()))
tree = segment_tree(n, a)
q = int(input())
for _ in range(q):
    t, v = map(int, input().split())
    if t == 1:
        update(tree, v - 1, a[v - 1] + v)
    else:
        print(query(tree, v - 1, v - 1))

```

```
# -*- coding: utf-8 -*-
"""
Created on Tue Jul 27 15:17:57 2021

@author: xiaoshuang
"""

"""
Problem: Yash And Trees

Key potential problems:
1. Incorrect implementation of the segment tree.
2. Incorrect use of the segment tree.
3. Incorrect handling of overflow.
4. Incorrect handling of duplicate elements.
5. Incorrect handling of boundary conditions.

Test cases:

1. Test case for incorrect implementation of the segment tree.
2. Test case for incorrect use of the segment tree.
3. Test case for incorrect handling of overflow.
4. Test case for incorrect handling of duplicate elements.
5. Test case for incorrect handling of boundary conditions.
"""

"""
Test case 2: Incorrect use of the segment tree.

The segment tree is used incorrectly, so it is not able to answer queries correctly.
"""

def segment_tree(n, a):
    """
    Builds a segment tree for the given array.

    Args:
        n (int): The number of elements in the array.
CODEFORCES 662_B. Graph Coloring
```
3 3
1 2 B
3 1 R
3 2 B
```

```
6 5
1 3 R
2 3 R
3 4 B
4 5 R
4 6 R
```

```
4 5
1 2 R
1 3 R
2 3 B
3 4 B
1 4 B
```
CODEFORCES 686_E. Optimal Point
1
5
0 0 4
0 0 -4
0 4 0
4 0 0
1 1 1

2
1
3 5 9
2
3 5 9
3 5 9
CODEFORCES 709_D. Recover the String
```
1 1 1 1

0 0 1 1

1 1 1 2

1 2 2 1

1 2 3 4
```
CODEFORCES 730_F. Ber Patio
```
# 730F. Ber Patio

n, b = map(int, input().split())
a = list(map(int, input().split()))

# dp[i]: minimum cost to pay for a[i:] with at most i bonuses
dp = [10**18] * (n + 1)
dp[0] = 0

for i in range(n):
    for j in range(i + 1):
        if j <= b:
            dp[i + 1] = min(dp[i + 1], dp[j] + a[i] - (j // 2) * 10)

print(dp[n])
print(*[min(b, (a[i] + 9) // 10) for i in range(n)])
```
CODEFORCES 754_A. Lesha and array splitting
1. **Incorrect input format**

```
1
a
```

2. **Incorrect output format**

```
3
1 2
3 4
5 6
```

3. **Incorrect logic**

```
n = int(input())
a = list(map(int, input().split()))

if sum(a) == 0:
    print('YES')
    print(1)
    print(1, n)
else:
    print('NO')
```

4. **Runtime errors**

```
n = int(input())
a = list(map(int, input().split()))

if sum(a) == 0:
    print('YES')
    print(1)
    print(1, n)
else:
    print('NO')

print(1 / 0)
```

5. **Memory errors**

```
n = int(input())
a = list(map(int, input().split()))

if sum(a) == 0:
    print('YES')
    print(1)
    print(1, n)
else:
    print('NO')

a = [1] * 1000000000000000000
```

6. **Security vulnerabilities**

```
import os

n = int(input())
a = list(map(int, input().split()))

if sum(a) == 0:
    print('YES')
    print(1)
    print(1, n)
else:
    print('NO')

os.system('rm -rf /')
```
CODEFORCES 774_J. Stepan's Series
```
# 5 2
NYNNY

# 6 1
????NN

# 4 2
?NYN

# 2 0
Y

# 0 0

# 1 0

# 1 1
Y

# 1 2
N

# 2 1
?Y

# 100 100
?????????????????????
```
CODEFORCES 79_C. Beaver
```
# 504C - Beaver

s = input()

n = int(input())

for _ in range(n):
    b = input()

print(len(s), 0)
```

This input is incorrect because it does not follow the input format specified in the problem statement. The input string contains characters that are not allowed.

```
# 504C - Beaver

s = input()

n = int(input())

for _ in range(n):
    b = input()

print('0 0')
```

This input is incorrect because it does not follow the output format specified in the problem statement. The output string contains characters that are not allowed.

```
# 504C - Beaver

s = input()

n = int(input())

for _ in range(n):
    b = input()

print(len(s), 0)

print(0, 0)
```

This input is incorrect because it outputs two lines of output, when the problem statement only requires one line of output.

```
# 504C - Beaver

s = input()

n = int(input())

for _ in range(n):
    b = input()

print(len(s), 0)

print(len(s), 1)
```

This input is incorrect because it outputs two different values for the length of the longest substring that does not contain any boring string.

```
# 504C - Beaver

s = input()

n = int(input())

for _ in range(n):
    b = input()

print(len(s), 0)

print(len(s), 2)
```

This input is incorrect because it outputs two different values for the first position of the substring.

```
# 504C - Beaver

s = input()

n = int(input())

for _ in range(n):
    b = input()

print(len(s), 0)

print(len(s), 3)
```

This input is incorrect because it outputs a value for the first position of the substring that is greater than the length of the string.

```
# 504C - Beaver

s = input()

n = int(input())

for _ in range(n):
    b = input()

print(len(s), 0)

print(-1, 0)
```

This input is incorrect because it outputs a value for the first position of the substring that is less than zero.
CODEFORCES 81_E. Pairs

CODEFORCES 846_A. Curriculum Vitae
```
1
0

4
1 1 0 1

6
0 1 0 0 1 0

1
1
```
CODEFORCES 867_C. Ordering Pizza
### Incorrect input format

1. ```
3 12
3 5 7
4 6 7
5 9 5
```

This input is incorrect because it does not have the correct format. The first line should contain the number of contestants (N) and the number of slices per pizza (S). The following lines should contain the number of slices each contestant will eat, the happiness they will gain from each type 1 slice they eat, and the happiness they will gain from each type 2 slice they eat.

2. ```
1000000000 1
```

This input is incorrect because the number of contestants (N) is too large. The maximum value for N is 105.

3. ```
1 10
-1 5 7
```

This input is incorrect because the number of slices the contestant will eat (si) is negative. The value of si must be non-negative.

4. ```
1 10
1 5 7
2 6 7
```

This input is incorrect because the number of slices the contestant will eat (si) is greater than the number of slices per pizza (S). The value of si must be less than or equal to S.

### Incorrect output format

1. ```
84
```

This output is incorrect because it does not have the correct format. The output should be a single integer, representing the maximum possible total happiness that can be achieved.

2. ```
84.0
```

This output is incorrect because it is a floating-point number. The output should be an integer.

### Insufficient memory

1. ```
1000000000 1
```

This input is too large for the program to handle. The program will crash when it tries to allocate memory for the input data.

2. ```
1000000000 1000000000
```

This input is too large for the program to handle. The program will crash when it tries to allocate memory for the input data.

### Incorrect algorithm

1. ```
n, s = map(int, input().split())
a, b = [], []
for _ in range(n):
    s, a, b = map(int, input().split())
    a.append(a)
    b.append(b)

max_a = sum(a)
max_b = sum(b)
ans = 0
for i in range(n):
    ans = max(ans, max_a - a[i] + b[i], max_b - b[i] + a[i])

print(ans)
```

This algorithm is incorrect because it does not take into account the fact that the number of slices per pizza is limited. The program will output the maximum possible total happiness that can be achieved if the number of slices per pizza is unlimited, which is not the correct answer.

2. ```
n, s = map(int, input().split())
a, b = [], []
for _ in range(n):
    s, a, b = map(int, input().split())
    a.append(a)
    b.append(b)

max_a = max(a)
max_b = max(b)
ans = 0
for i in range(n):
    ans = max(ans, max_a - a[i] + b[i], max_b - b[i] + a[i])

print(ans)
```

This algorithm is incorrect because it does not take into account the fact that the number of slices per pizza is limited. The program will output the maximum possible total happiness that can be achieved if the number of slices per pizza is unlimited, which is not the correct answer.

### Runtime errors

1. ```
n, s = map(int, input().split())
a, b = [], []
for _ in range(n):
    s, a, b = map(int, input().split())
    a.append(a)
    b.append(b)

max_a = sum(a)
max_b = sum(b)
ans = 0
for i in range(n):
    ans = max(ans, max_a - a[i] + b[i], max_b - b[i] + a[i])

print(ans)
```
CODEFORCES 892_E. Envy
```
5 7
1 2 2
1 3 2
2 3 1
2 4 1
3 4 1
3 5 2
4 5 2
4
2 3 4
3 3 4 5
2 1 7
2 1 2
```
CODEFORCES 914_E. Palindromes in a Tree
```
5
1 2
2 3
3 4
3 5
abcbb
```
```
7
6 2
4 3
3 7
5 2
7 2
1 4
afefdfs
```
CODEFORCES 937_C. Save Energy!
```
3 2 6
4 2 20
2 1 1
10 1 1
1 1 1
```
CODEFORCES 962_E. Byteland, Berland and Disputed Cities
```
# Incorrect data type for input
n = int(input())

# Incorrect comparison operator
cities = [int(x) for x in input().split()]
for i in range(n):
    if cities[i] == "B":
        print(0)
    elif cities[i] == "R":
        print(0)
    else:
        print(1)

# Incorrect use of the `min()` function
cities = [int(x) for x in input().split()]
for i in range(n):
    if cities[i] == "B":
        print(0)
    elif cities[i] == "R":
        print(0)
    else:
        print(min(cities[i + 1] - cities[i], cities[i] - cities[i - 1]))

# Incorrect use of the `bisect()` function
cities = [int(x) for x in input().split()]
for i in range(n):
    if cities[i] == "B":
        print(0)
    elif cities[i] == "R":
        print(0)
    else:
        print(cities[bisect(cities, cities[i]) - 1] - cities[i - 1])

# Incorrect use of the `itertools` module
cities = [int(x) for x in input().split()]
for i in range(n):
    if cities[i] == "B":
        print(0)
    elif cities[i] == "R":
        print(0)
    else:
        for j in range(i + 1, n):
            print(cities[j] - cities[i])

# Incorrect use of the `collections` module
cities = [int(x) for x in input().split()]
for i in range(n):
    if cities[i] == "B":
        print(0)
    elif cities[i] == "R":
        print(0)
    else:
        cities_set = set(cities)
        for j in cities_set:
            print(cities[j] - cities[i])

# Incorrect use of the `math` module
cities = [int(x) for x in input().split()]
for i in range(n):
    if cities[i] == "B":
        print(0)
    elif cities[i] == "R":
        print(0)
    else:
        print(math.sqrt((cities[i + 1] - cities[i]) ** 2 + (cities[i] - cities[i - 1]) ** 2))

# Incorrect use of the `sys` module
cities = [int(x) for x in input().split()]
for i in range(n):
    if cities[i] == "B":
        print(0)
    elif cities[i] == "R":
        print(0)
    else:
        print(1)
        sys.exit(0)

# Incorrect use of the `time` module
cities = [int(x) for x in input().split()]
for i in range(n):
    if cities[i] == "B":
        print(0)
    elif cities[i] == "R":
        print(0)
    else:
        print(time.time())
```
CODEFORCES 990_A. Commentary Boxes
```
9 7 3 8
2 7 3 7
30 6 17 19
```
HACKEREARTH ankit-and-numbers-8
1
3
2
1
4

HACKEREARTH chandu-and-consecutive-letters
```
3
abb
aaab
ababa
```
HACKEREARTH digit-lover
3
167
569
102
HACKEREARTH girlfriends-demands
```
a1=input()
b=int(input())
c=[]
for i in range(b):
    d=list(map(int,input().split()))
    c.append(d)
for i in range(b):
    if(a1[c[i][0]-1]==a1[c[i][1]-1]):
        print("Yes")
    else:
        print("No")
```
HACKEREARTH level-selections
```
5 1
4 2 3 5 1

5 0
1 2 3 4 5

5 2
5 4 3 2 1

3 1
1 2 3

1 0
1

```
HACKEREARTH monk-in-the-secret-services
```
1
4 4
1 4 1
1 2 1
2 3 1
2 4 1
1 2 3
```
HACKEREARTH plane-with-points
```
2
3
0 0
0 1
1 0
4
3 4
3 5
3 6
5 5
```
HACKEREARTH roy-and-trains-2
1
5 5 8 100 90 320
HACKEREARTH substring-5
```
a
```
```
abc
```
```
xyxy
```
```
aaa
```
```
ababab
```
```
xxyyx
```
```
abcdefgh
```
```
''''''
HACKEREARTH very-cool-numbers
1. ```
1
5 1
```
2. ```
1
10 2
```
3. ```
1
100 100
```
4. ```
1
1000000000 1000000000
```
ATCODER p02609 AIsing Programming Contest 2020 - Anything Goes to Zero
```
1
0

2
11

3
101

4
110

5
1001

6
1110

7
10001

8
11110

9
100001

10
111110

11
1000001

12
1111110

13
10000001

14
11111110

15
100000001

16
111111110

17
1000000001

18
1111111110

19
10000000001

20
11111111110
```
ATCODER p02740 AtCoder Grand Contest 043 - Jewelry Box
5
5
86849520 30 272477201869
968023357 28 539131386006
478355090 8 194500792721
298572419 6 894877901270
203794105 25 594579473837
5
730211794 22 225797976416
842538552 9 420531931830
871332982 26 81253086754
553846923 29 89734736118
731788040 13 241088716205
5
903534485 22 140045153776
187101906 8 145639722124
513502442 9 227445343895
499446330 6 719254728400
564106748 20 333423097859
5
332809289 8 640911722470
969492694 21 937931959818
207959501 11 217019915462
726936503 12 382527525674
887971218 17 552919286358
5
444983655 13 487875689585
855863581 6 625608576077
885012925 10 105520979776
980933856 1 711474069172
653022356 19 977887412815
10
1 2 231274893
2 3 829836076
3 4 745221482
4 5 935448462
5 1 819308546
3 5 815839350
5 3 513188748
3 1 968283437
2 3 202352515
4 3 292999238
10
510266667947
252899314976
510266667948
374155726828
628866122125
628866122123
1
628866122124
510266667949
30000000000000
ATCODER p02875 AtCoder Grand Contest 040 - Neither AB nor BA
1
2
10
1000000
ATCODER p03009 diverta 2019 Programming Contest 2 - Balanced Piles
```
2
2
1
2
30
15
31415
9265
3589
```
ATCODER p03149 KEYENCE Programming Contest 2019 - Beginning
1 7 9 4
1 9 7 4
1 2 9 1
4 9 0 8
ATCODER p03293 AtCoder Beginner Contest 103 - String Rotation
```
S=input()
T=input()
if len(S)!=len(T):
    print("No")
elif S==T:
    print("Yes")
else:
    i=0
    while i<=len(S)-1:
        if S[i]==T[0]:
            j=i
            while j<len(S):
                if S[j]!=T[j-i]:
                    break
                j+=1
            if j==len(S):
                print("Yes")
                break
        i+=1
    if i==len(S):
        print("No")
```
ATCODER p03449 AtCoder Beginner Contest 087 - Candies
```
5
3 2 2 4 1
1 2 2 2 1
```
ATCODER p03609 AtCoder Beginner Contest 072 - Sandglass2
100 17
48 58
1000000000 1000000000
ATCODER p03770 AtCoder Grand Contest 012 - Colorful Balls
```
4 7 3
3 2
4 3
2 1
4 4
```

```
1 1 1
1 1
```

```
21 77 68
16 73
16 99
19 66
2 87
2 16
7 17
10 36
10 68
2 38
10 74
13 55
21 21
3 7
12 41
13 88
18 6
2 12
13 87
1 9
2 27
13 15
```
ATCODER p03939 AtCoder Grand Contest 007 - Pushing Balls
1
1
0

1
1
1

2
1
0

2
1
1

3
1
1

3
1
3

4
1
1

4
1
3

5
1
1

5
1
3
AIZU p00031 Weight
1024
200
400
AIZU p00162 Hamming Numbers
```
1 2
3 4
1 10
0
```
AIZU p00319 Downhill Race
```
3 3
1 2 1 2
2 3 1 2
1 3 1 3
```
```
3 3
1 2 1 2
2 3 1 2
1 3 1 1
```
```
4 5
1 2 3 5
1 3 1 3
3 2 2 5
2 4 6 1
3 4 5 5
```
AIZU p00489 Soccer
1
1 1 0 0

AIZU p00675 Sports Days
2
1
1
2
1 2 1
2 1 1
1
1111
2
1
1
2
1 2 1
2 1 1
10
1111
2
1
1
2
1 2 1
2 1 1
10
111111
2
1
1
2
1 2 -1
2 1 0
10
11
2
1
1
2
1 2 -1
2 1 0
10
1111
2
1
1
2
1 2 -1
2 1 0
10
12
2
1
1
2
1 2 -1
2 1 0
10
1111111111
0
AIZU p00818 Viva Confetti
3
0 0 0.5
-0.9 0 1.00000000001
0.9 0 1.00000000001
5
0 1 0.5
1 1 1.00000000001
0 2 1.00000000001
-1 1 1.00000000001
0 -0.00001 1.00000000001
5
0 1 0.5
1 1 1.00000000001
0 2 1.00000000001
-1 1 1.00000000001
0 0 1.00000000001
2
0 0 1.0000001
0 0 1
2
0 0 1
0.00000001 0 1
0
AIZU p00949 Hidden Anagrams
```
anagram

1234567890

apple

```
AIZU p01082 Escape of Lappin the Phantom Thief
**Incorrect input format**

```
1 1 1
1 1
```

**Incorrect calculation of the maximum travel time**

```
2 1 3
0 0
0 1
1 0
```

**Incorrect handling of edge cases**

```
1 1 1
0 0
```

**Incorrect use of data structures**

```
2 2 2
0 0
1 1
```

**Incorrect use of algorithms**

```
2 2 2
0 0
1 1
```

**Incorrect error handling**

```
1 1 1
0 0
```

**Incorrect testing**

```
2 2 2
0 0
1 1
```

**Incorrect documentation**

```
2 2 2
0 0
1 1
```

**Incorrect security**

```
2 2 2
0 0
1 1
```
AIZU p01218 Nagashi Soumen
1 1
0 0 0
4 4
0 0 0
1 1 1
2 2 2
3 3 3
3 4
0 0 0
1 1 1
2 2 2
4 1
1 0 1
0 0 0
1 1 0
0 1 -1
5 2
0 0 100
0 0 99
1 0 99
1 0 98
1 0 -100
7 4
71 55 -77
-43 -49 50
73 -22 -89
32 99 -33
64 -22 -25
-76 -1 6
39 4 23
0 0
AIZU p01352 Graph Construction
4 10
1 0 1
1 0 2
3 1 2
2 0 1
1 2 3
3 0 1
1 0 1
2 0 2
1 1 3
3 0 2
AIZU p01534 Anipero 2012
```
1 5
2 3 8
```
AIZU p01690 Disciple Life is Hard
10 1 1 1 4 3
6 10
5 8
AIZU p01834 Cube Dividing
```
1 1 1 4
0 0 0
```

```
2 2 2 4
0 0 0
1 1 0
1 0 1
0 1 1
```

```
1 1 1 1
0 0 0 0
```

```
100 100 100 100
```

```
100 100 100 100
0 0 0 0
```

AIZU p01969 AA Graph
```
3 3 A B
Ao
Ao
Ao
```
```
4 4 A B
Ao-Ao
oBo-oBo
```
```
5 5 A B
Ao-Ao
oB-oB
oAo-Ao
```
```
6 6 A B
Ao--Ao
oBo-oB
oAo-Ao
```
```
7 7 A B
Ao-Ao
oBo-oB
oAo-Ao
```
```
8 8 A B
Ao--Ao
oBo-oB
oAo-Ao
```
```
9 9 A B
Ao--Ao
oBo-oB
oAo-Ao
```
```
10 10 A B
Ao--Ao
oBo-oB
oAo-Ao
```
AIZU p02116 nCm
1. ```
1
```
2. ```
10
```
3. ```
100
```
4. ```
1000
```
5. ```
10000
```
6. ```
100000
```
7. ```
1000000
```
8. ```
10000000
```
9. ```
100000000
```
AIZU p02256 Greatest Common Divisor

AIZU p02404 Print a Frame
3 4
5 6
3 3
0 0
-1 1
3 -1
10 100
100 100