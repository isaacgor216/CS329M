CODECHEF bintour
3

4

5
CODECHEF cntsols
```
1
1 2 2 5
```
```
1
1 2 3 31
```
```
10
4 2 4 5
1000000000 998244353 41 41
1000000000 1 1 1
1000000000 1 2013 3 31
1000000000 2 2 3 5
1000000000 2 2 3 5
1000000000 2 2 3 5
1000000000 1 1 1 1
1000000000 2 1 1 1
```
CODECHEF frogv
5 3 3
0 3 8 5 12
1 2
1 3
2 5
CODECHEF lstgrph
```
5 4 2
1 2 5
1 3 9
2 4 0
2 5 1
```
CODECHEF prladdu
```
1
3
5 -5 0
```
```
1
5
5 0 -5
```
```
1
3
1 2 -3
```
```
1
5
-5 5 0
```
```
2
4
-2 1 0 3
4
-2 1 0 3
```
```
3
5
-2 1 0 3
5
-2 1 0 3
5
-2 1 0 3
```
```
4
5
-2 1 0 3
5
-2 1 0 3
5
-2 1 0 3
5
-2 1 0 3
```
CODECHEF tavisual
1
5 2 3
1 4
3 5
1 5
CODEFORCES 1011_C. Fly
```
2
12
11 8
7 5
```
```
3
1
1 4 1
2 5 3
```
```
6
2
4 6 3 3 5 6
2 6 3 6 5 3
```
```
1
1
11 10
10
```
```
1
2
10 10
10
```
CODEFORCES 1036_D. Vasya and Arrays
```
5
11 2 3 5 7
4
11 7 3 7

2
1 2
1
100

3
1 2 3
3
1 2 3
```
CODEFORCES 1059_C. Sequence Transformation
1. ```
1
```
2. ```
2
```
3. ```
3
```
4. ```
4
```
5. ```
5
```
6. ```
6
```
7. ```
7
```
8. ```
8
```
9. ```
9
```
10. ```
10
```
CODEFORCES 1080_E. Sonya and Matrix Beauty
```
1 3
aba
```
```
2 3
aca
aac
```
```
3 5
accac
aaaba
cccaa
```
CODEFORCES 10_D. LCIS
```
1
1
1
1
```
```
5
1 2 3 4 5
5
5 4 3 2 1
```
```
5
1 2 3 4 5
4
1 3 5 6
```
```
6
2 3 1 6 5 4
4
1 3 5 6
```
```
5
1 2 0 2 1
3
1 0 1
```
CODEFORCES 1121_C. System Testing
```
2 1
49 100
```
```
4 2
32 100 33 1
```
```
14 5
48 19 6 9 50 20 3 42 38 43 36 21 44 6
```
CODEFORCES 1148_E. Earth Wind and Fire
```
2
1 2
2 2
```
```
3
1 2 3
1 3 1
```
```
3
1 2 3
3 2 1
```
```
6
1 2 3 4 5 6
2 5 2
4 6 3
1 2 1
3 4 1
```
```
10
1 2 3 4 5 6 7 8 9 10
1 2 1
2 3 1
3 4 1
4 5 1
5 6 1
6 7 1
7 8 1
8 9 1
9 10 1
```
CODEFORCES 116_B. Little Pigs and Wolves
1. Incorrect input format

```
1 2
P.
```

2. Incorrect output format

```
1 2
P.
```

3. Incorrect logic

```
1 2
P.
```

4. Runtime error

```
1 2
P.
```
CODEFORCES 1188_A2. Add on a Tree: Revolution
```
5
1 2 2
2 3 4
3 4 10
3 5 18

```
CODEFORCES 1207_B. Square Filling
```
# Problem: CODEFORCES 1207_B. Square Filling

# Input:

3 3
1 1 1
1 1 1
0 1 1

# Output:

3
1 1
1 2
2 2
```
CODEFORCES 1225_C. p-binary
1. ```
1 1
```
2. ```
1 0
```
3. ```
24 0
```
4. ```
24 1
```
5. ```
24 -1
```
6. ```
4 -7
```
7. ```
2 2
```
8. ```
24 -2
```
9. ```
24 -1000
```
10. ```
1 1000
```
CODEFORCES 1249_E. By Elevator or Stairs?
```
10 2
7 6 18 6 16 18 1 17 17
6 9 3 10 9 1 10 1 5
```
CODEFORCES 1268_B. Domino for Young
```
5
3 2 2 2 1
```
CODEFORCES 1290_C. Prefix Enlightenment
```
1. **Incorrect understanding of the problem statement.**

```
```
2. **Incorrect implementation of the algorithm.**

```
```
3. **Incorrect testing.**

```
```
4. **Incorrect submission.**

```
```
5. **Incorrect runtime.**

```
```
```
```
CODEFORCES 1310_D. Tourism
```
2 1
0
```
```
3 3
1 2 3
2 1 3
3 2 1
```
```
4 5
0 1 2 3 4
0 0 1 1 2
0 1 0 0 0
2 1 1 0 0
2 0 1 2 0
```
```
5 8
0 1 2 2 0
0 0 1 1 2
0 1 0 0 0
2 1 1 0 0
2 0 1 2 0
```
```
2 1
2
```
```
5 10
0 1 2 2 0
0 0 1 1 2
0 1 0 0 0
2 1 1 0 0
2 0 1 2 0
```
CODEFORCES 1333_B. Kind Anton
```
1
3
1 -1 0
1 1 -2
```
CODEFORCES 1353_E. K-periodic Garland
1
2
9 2
010001010
9 3
111100000
7 4
1111111
10 3
1001110101
1 1
1
1 1
0
CODEFORCES 1373_D. Maximum Sum on Even Positions
1. ```
1
4
1 7 3 4
```
2. ```
1
5
1 2 1 2 1
```
3. ```
1
10
7 8 4 5 7 6 8 9 7 3
```
4. ```
1
4
3 1 2 1
```
CODEFORCES 1396_C. Monster Invaders
**Incorrect calculation of the minimum time to finish the game.**
```
n, r1, r2, r3, d = map(int, input().split())
a = list(map(int, input().split()))

def get_time(a, pos):
    time = 0
    
    for i in range(pos, n):
        if a[i] > 1:
            time += r1 + r2
            time += d if i > 1 else 0
        else:
            time += r1
    
    return time

def solve():
    min_time = 10**18
    
    for i in range(n):
        for j in range(i+1, n):
            for k in range(j+1, n):
                if a[i] + a[j] + a[k] >= 2:
                    min_time = min(min_time, get_time(a, i) + get_time(a, j) + get_time(a, k))
    
    print(min_time)

solve()
```

**Using an incorrect algorithm to solve the problem.**
```
n, r1, r2, r3, d = map(int, input().split())
a = list(map(int, input().split()))

def get_time(a, pos):
    time = 0
    
    for i in range(pos, n):
        if a[i] > 1:
            time += r1 + r2
            time += d if i > 1 else 0
        else:
            time += r1
    
    return time

def solve():
    # Incorrect algorithm
    min_time = 10**18
    
    for i in range(n):
        for j in range(i+1, n):
            for k in range(j+1, n):
                if a[i] + a[j] + a[k] >= 2:
                    min_time = min(min_time, get_time(a, i) + get_time(a, j) + get_time(a, k))
    
    # Correct algorithm
    for i in range(n):
        for j in range(i+1, n):
            if a[i] + a[j] >= 2:
                min_time = min(min_time, get_time(a, i) + get_time(a, j))
    
    print(min_time)

solve()
```

**Incorrect implementation of the algorithm.**
```
n, r1, r2, r3, d = map(int, input().split())
a = list(map(int, input().split()))

def get_time(a, pos):
    time = 0
    
    for i in range(pos, n):
        if a[i] > 1:
            time += r1 + r2
            time += d if i > 1 else 0
        else:
            time += r1
    
    return time

def solve():
    min_time = 10**18
    
    for i in range(n):
        for j in range(i+1, n):
            if a[i] + a[j] >= 2:
                min_time = min(min_time, get_time(a, i) + get_time(a, j))
    
    print(min_time)

solve()
```

**Incorrect input or output.**
```
n, r1, r2, r3, d = map(int, input().split())
a = list(map(int, input().split()))

def get_time(a, pos):
    time = 0
    
    for i in range(pos, n):
        if a[i] > 1:
            time += r1 + r2
            time += d if i > 1 else 0
        else:
            time += r1
    
    return time

def solve():
    min_time = 10**18
    
    for i in range(n):
        for j in range(i
CODEFORCES 141_E. Clearing Up
```
# 1. Incorrect input format

1 2
1 1 M

```

```
# 2. Incorrect output format

1 2
1 2 S

```

```
# 3. Incorrect logic

3 3
1 2 S
1 3 M
2 3 S

```

```
# 4. Memory leaks

```

```
# 5. Race conditions

```

```
# 6. Deadlocks

```

```
# 7. Unhandled exceptions

```

```
# 8. Security vulnerabilities

```

```
# 9. Performance problems

```
CODEFORCES 1438_E. Yurii Can Do Everything
```
3
3 1 2
```
```
8
3 1 2 3 1 2 3 15
```
```
10
997230370 58052053 240970544 715275815 250707702 156801523 44100666 64791577 43523002 480196854
```
CODEFORCES 1463_D. Pairs
```
1
1
2
1 2
```
CODEFORCES 148_D. Bag of mice
```
1 3
```
```
5 5
```
```
5 1000
```
```
1000 1000
```
```
-1 1
```
```
1001 1001
```
CODEFORCES 1512_B. Almost Rectangle
1
4
..*.
....
*...
....
3
*.*
...
...
2
*.
.*

CODEFORCES 1539_F. Strange Array
```
5
5 4 3 2 1
```

```
7
3 6 5 6 2 1 3
```
CODEFORCES 166_C. Median
```
# 1. Incorrect input format

1 1
1

# 2. Incorrect data type

1 1
a

# 3. Out-of-bounds errors

5 100
1 2 3 4 5

# 4. Division by zero

1 0
1

# 5. Off-by-one errors

3 4
1 2 3

# 6. Logical errors

3 4
1 2 3

# 7. Runtime errors

1000000000 1000000000
1 2 3 4 5 6 7 8 9 10

# 8. Security vulnerabilities

```
CODEFORCES 187_D. BRT Contract 
```
1 3 2
5 2
5
1
2
3
4
5
```
CODEFORCES 208_B. Solitaire
```
1
2S
```
```
1
3S
```
```
2
3S 2C
```
```
4
2S 2S 2C 2C
```
```
5
2S 2S 2C 2C 2H
```
CODEFORCES 233_E. Doe Graphs
```
10 5
1 2
1 3
1 4
1 5
2 3
2 4
2 5
3 4
3 5
4 5
```
CODEFORCES 259_D. Little Elephant and Elections
**1. Using the wrong modulo operator.**

```
m = int(input())
print(m % 1000000007)
```

**2. Using the wrong data type.**

```
m = float(input())
print(m % 1000000007)
```

**3. Not handling invalid input.**

```
m = input()
print(m % 1000000007)
```

**4. Not using the correct algorithm.**

```
m = int(input())

def count_lucky_digits(n):
  return sum(1 for digit in str(n) if digit in ["4", "7"])

def count_assignments(m):
  return m * (m - 1) * (m - 2) * (m - 3) * (m - 4) * (m - 5) * (m - 6) // 120

print(count_assignments(m) % 1000000007)
```

**5. Not using the correct data structures.**

```
m = int(input())

def count_lucky_digits(n):
  return sum(1 for digit in str(n) if digit in ["4", "7"])

def count_assignments(m):
  lucky_digits = [0] * m
  for i in range(m):
    lucky_digits[i] = count_lucky_digits(i + 1)
  return lucky_digits[m - 1] * (m - 1)

print(count_assignments(m) % 1000000007)
```

**6. Not using the correct time and space complexity.**

```
m = int(input())

def count_lucky_digits(n):
  return sum(1 for digit in str(n) if digit in ["4", "7"])

def count_assignments(m):
  lucky_digits = [0] * m
  for i in range(m):
    lucky_digits[i] = count_lucky_digits(i + 1)
  lucky_digits.sort()
  # O(n^2) time complexity
  for i in range(m - 1):
    for j in range(i + 1, m):
      if lucky_digits[j] - lucky_digits[i] > 6:
        return 1
  return 0

print(count_assignments(m) % 1000000007)
```
CODEFORCES 282_D. Yet Another Number Game
```
1
300
```
```
2
300 300
```
```
3
1 2 3
```
```
3
1 0 0
```
CODEFORCES 305_C. Ivan and Powers of Two
```
1
3
```
```
4
0 1 1 1
```
```
1
4
```
```
2
1 2
```
```
1
1000000000
```
```
10
1 2 3 4 5 6 7 8 9 10
```
```
3
1 2 3
```
```
100
500 700 900 1100 1300 1500 1700 1900 2100 2300 2500 2700 2900 3100 3300 3500 3700 3900 4100 4300 4500 4700 4900 5100 5300 5500 5700 5900 6100 6300 6500 6700 6900 7100 7300 7500 7700 7900 8100 8300 8500 8700 8900 9100 9300 9500 9700 9900
```
CODEFORCES 331_B2. Shave Beaver!
1. Incorrect data type
```
n = int(input())
a = list(map(str,input().split()))
q = int(input())
b = list(map(str,input().split()))
solve(n,q,a,b)
```

2. Incorrect index
```
n = int(input())
a = list(map(int,input().split()))
q = int(input())
b = list(map(int,input().split()))
solve(n,q,a,b)
```

3. Off-by-one error
```
n = int(input())
a = list(map(int,input().split()))
q = int(input())
b = list(map(int,input().split()))
solve(n,q,a,b)
```

4. Incorrect logic
```
n = int(input())
a = list(map(int,input().split()))
q = int(input())
b = list(map(int,input().split()))
solve(n,q,a,b)
```

5. Memory leak
```
n = int(input())
a = list(map(int,input().split()))
q = int(input())
b = list(map(int,input().split()))
solve(n,q,a,b)
```

6. Security vulnerability
```
n = int(input())
a = list(map(int,input().split()))
q = int(input())
b = list(map(int,input().split()))
solve(n,q,a,b)
```
CODEFORCES 353_B. Two Heaps
```
1
10 99
```

```
2
13 24 13 45
```

```
2
10 20 30 40 50 60 70 80 90
```

```
3
10 20 30 40 50 60 70 80 90 100
```
CODEFORCES 377_C. Captains Mode
```
2
2 1
2
p 1
p 2
```
CODEFORCES 399_E. Tree and Array
```
5
```
CODEFORCES 424_A. Squats
```
4
xxxX

2
XX

6
xXXXxXx
```
CODEFORCES 448_D. Multiplication Table
```
1 1 1
2 2 2
2 3 4
1 10 5
2 3 1
```
CODEFORCES 46_E. Comb
```
1 1
10

2 2
-1 2
1 3

2 3
-1 2 3
1 4 5
```
CODEFORCES 493_A. Vasya and Football
**Incorrect input format**

```
A
B
1
1 2 r
```

**Incorrect output format**

```
A 2 2
```

**Undefined behavior**

```
A
B
0
```

**Memory leaks**

```
#include <iostream>

using namespace std;

int main() {
  int n;
  cin >> n;

  for (int i = 0; i < n; i++) {
    int t, h, m, r;
    cin >> t >> h >> m >> r;
  }

  return 0;
}
```

**Race conditions**

```
#include <iostream>
#include <thread>

using namespace std;

int main() {
  int n;
  cin >> n;

  for (int i = 0; i < n; i++) {
    int t, h, m, r;
    cin >> t >> h >> m >> r;
  }

  thread t1([]() {
    for (int i = 0; i < n; i++) {
      int t, h, m, r;
      cin >> t >> h >> m >> r;
    }
  });

  thread t2([]() {
    for (int i = 0; i < n; i++) {
      int t, h, m, r;
      cin >> t >> h >> m >> r;
    }
  });

  t1.join();
  t2.join();

  return 0;
}
```

**Deadlocks**

```
#include <iostream>
#include <thread>

using namespace std;

int main() {
  int n;
  cin >> n;

  for (int i = 0; i < n; i++) {
    int t, h, m, r;
    cin >> t >> h >> m >> r;
  }

  thread t1([]() {
    while (true) {
      int t, h, m, r;
      cin >> t >> h >> m >> r;
    }
  });

  thread t2([]() {
    while (true) {
      int t, h, m, r;
      cin >> t >> h >> m >> r;
    }
  });

  t1.join();
  t2.join();

  return 0;
}
```

**Security vulnerabilities**

```
#include <iostream>
#include <string>

using namespace std;

int main() {
  string input;
  cin >> input;

  if (input == "password") {
    cout << "Access granted" << endl;
  } else {
    cout << "Access denied" << endl;
  }

  return 0;
}
```

**Unit tests**

```
#include <iostream>

using namespace std;

int main() {
  // Test case 1
  int n = 1;
  int t1 = 1;
  char h1 = 'h';
  int m1 = 1;
  char r1 = 'r';

  // Expected output
  string expected_output = "A 1 1";

  // Actual output
  string actual_output = get_red_cards(n, t1, h1, m1, r1);

  // Check if the actual output matches the expected output
  if (actual_output == expected_output) {
    cout << "Test case 1 passed" << endl;
  } else {
    cout << "Test case 1 failed" << endl;
  }

  // Test case 2
  n = 2;
  t1 = 1;
  h1 = 'h';
  m1 = 1;
  r1 = 'r';
  t2 = 2;
  h2 = 'a';
  m2 = 2;
  r2 = 'r';

  // Expected output
  expected_output
CODEFORCES 516_E. Drazil and His Happy Friends
1. Incorrect input format:
```
2 3
0
4 5
```

2. Incorrect output format:
```
2 3
1 0
1 1
a
```

3. Incorrect logic:
```
2 3
1 0
1 1
2
```

4. Memory leak:
```
n, m = map(int, input().split())
b = int(input())
x = list(map(int, input().split()))
g = int(input())
y = list(map(int, input().split()))

for i in range(n * m + 1):
    if i % n in x and i % m in y:
        print(i)
        break
```

5. Time complexity:
```
n, m = map(int, input().split())
b = int(input())
x = list(map(int, input().split()))
g = int(input())
y = list(map(int, input().split()))

for i in range(n * m + 1):
    if i % n in x and i % m in y:
        print(i)
        break
```

6. Space complexity:
```
n, m = map(int, input().split())
b = int(input())
x = list(map(int, input().split()))
g = int(input())
y = list(map(int, input().split()))

for i in range(n * m + 1):
    if i % n in x and i % m in y:
        print(i)
        break
```
CODEFORCES 543_E. Listening to Music
```
5 3
1 2 1 2 3
5
1 1 2
1 3 2
1 3 3
1 3 5
1 3 1
```
CODEFORCES 570_B. Simple Game
```
#Incorrect input format

1 2

#Incorrect calculation of the probability of winning

3 2

#Using an incorrect algorithm

4 3

#Not handling special cases

5 5

#Not using the most efficient algorithm

1000000000 1000000000
```
CODEFORCES 591_E. Three States
**1. Incorrect input format**

```
1 5
1#2#3
```

**2. Incorrect data**

```
-1 5
1#2#3
```

**3. Incorrect algorithm**

```
4 5
11..2
#..22
#.323
.#333
```

**4. Incorrect output format**

```
4 5
11..2
#..22
#.323
.#333
1
```

**5. Other bugs**

```
4 5
11..2
#..22
#.323
.#333
```

```
4 5
11..2
#..22
#.323
.#333
3
```
CODEFORCES 613_C. Necklace
1. ```
1
4
```
2. ```
2
1 1
```
3. ```
3
4 2 1
```
4. ```
4
1 1 1 1
```
5. ```
5
1 2 1 2 1
```
6. ```
6
1 2 2 1 2 1
```
7. ```
7
2 2 2 2 2 2 2
```
8. ```
8
1 1 1 1 1 1 1 1
```
9. ```
9
1 1 1 1 1 1 1 1 1
```
10. ```
10
1 1 1 1 1 1 1 1 1 1
```
CODEFORCES 633_C. Spy Syndrome 2
```
10
epyt
5
apple
eat
pea
tea
y

10
y
5
apple
eat
pea
tea
y

30
ariksihsidlihcdnaehsetahgnisol
10
Kira
hates
is
he
losing
death
childish
L
and
Note

12
iherehtolleh
5
HI
Ho
there
HeLLo
hello

```
CODEFORCES 661_F. Primes in Interval
1. ```
10 20
```
2. ```
23 23
```
3. ```
271 566
```
CODEFORCES 686_A. Free Ice Cream
1. 1 1
2. 1 0
3. 1 1
4. 1 0
5. 100 0
6. 100 0
7. 10 10
8. 10 0
9. 10 0
10. 5 7
11. 2 5
12. 2 10
13. 2 20
14. 2 40
15. 2 20
16. 2 5
17. 2 0
18. 2 10
19. 2 0
20. 5 17
21. 2 16
22. 2 2
23. 2 98
24. 2 100
25. 2 98
CODEFORCES 708_E. Student's Camp
```
# 5 1
# 3 10
# 1

# 2 2
# 1 2
# 1

# 3 3
# 1 10
# 5
```
CODEFORCES 730_B. Minimum and Maximum
```
2
2
>
3
=
=
```
CODEFORCES 750_H. New Year and Snowy Grid
```
3 5 4
.....
.....
.#...
1
1 4
1
1 5
2
2 4
3 1
2
1 5
3 3
```
```
9 31 5
...............................
...............................
.###.###.#.###...###.###.#.###.
...#.#.#.#.#.......#.#.#.#...#.
.###.#.#.#.###...###.#.#.#...#.
.#...#.#.#.#.#...#...#.#.#...#.
.###.###.#.###...###.###.#...#.
...............................
...............................
5
6 5
2 11
1 14
8 15
2 14
5
2 14
1 14
8 16
6 5
2 11
3
2 2
1 4
```
```
8 30 10
3 1
3 11
5 16
7 21
4 16
3 5
7 31
3 9
7 25
3 27
10
3 1
3 9
7 25
3 27
7 21
4 17
3 5
7 31
4 16
3 11
```
CODEFORCES 774_F. Pens And Days Of Week
```
1
10
```

```
2
2 4
```

```
3
1 1 2
```

```
4
3 4 5 6
```

```
5
1 5 2 4 4
```

```
6
5 4 1 3 2
```

```
7
5 5 5 5 5
```

```
8
1 2 3 4 5 6 7 8
```
CODEFORCES 799_F. Beautiful fountains rows
```
1 5
2 4
```
CODEFORCES 81_A. Plug-in
1. ```
a
```
2. ```
12345
```
3. ```
aa
```
4. ```

```
5. ```
a
```
6. ```
aa
```
7. ```
aaa
```
8. ```
aabbc
```
9. ```
abbba
```
10. ```
^a$
```
CODEFORCES 845_D. Driving Test

CODEFORCES 865_F. Egg Roulette
```
1 1
??BB
```
```
2 4
?BA??B??A???
```
```
4 14
????A??BB?????????????AB????????????
```
```
1 1
??BB
```
```
3 5
??AB?A
```
```
3 5
??AB?A
```
```
5 5
??AB?A
```
```
1 1
??BB
```
```
1 1
??BB
```
```
10 10
??AB?A
```
```
10 10
??AB?A
```
```
10 10
??AB?A
```
CODEFORCES 892_A. Greed
```
2
3 5
3 6

2
6 8 9
6 10 12

5
0 0 5 0 0
1 1 8 10 5

4
4 1 0 3
5 2 2 3
```
CODEFORCES 914_A. Perfect Squares
```
# 1. Using the wrong algorithm
```
```
n = int(input())
a = list(map(int, input().split()))

ans = 0
for i in range(n):
    if not is_perfect_square(a[i]):
        ans = max(ans, a[i])

print(ans)


def is_perfect_square(x):
    if x < 0:
        return False
    s = int(x ** 0.5)
    return s * s == x
```

```
# 2. Not handling negative numbers correctly
```
```
n = int(input())
a = list(map(int, input().split()))

ans = 0
for i in range(n):
    if not is_perfect_square(abs(a[i])):
        ans = max(ans, a[i])

print(ans)
```

```
# 3. Not handling floating-point numbers correctly
```
```
n = int(input())
a = list(map(float, input().split()))

ans = 0
for i in range(n):
    if not is_perfect_square(round(a[i])):
        ans = max(ans, a[i])

print(ans)
```

```
# 4. Not handling overflow correctly
```
```
n = int(input())
a = list(map(int, input().split()))

ans = 0
for i in range(n):
    if not is_perfect_square(a[i]):
        ans = max(ans, a[i])

print(ans)
```

```
# 5. Not handling degenerate cases correctly
```
```
n = int(input())
a = list(map(int, input().split()))

if n == 0:
    print(0)
else:
    ans = 0
    for i in range(n):
        if not is_perfect_square(a[i]):
            ans = max(ans, a[i])

    print(ans)
```

```
# 6. Not using the right data structures
```
```
n = int(input())
a = list(map(int, input().split()))

ans = 0
for i in range(n):
    if not is_perfect_square(a[i]):
        ans = max(ans, a[i])

print(ans)
```

```
# 7. Not using the right algorithms
```
```
n = int(input())
a = list(map(int, input().split()))

ans = 0
for i in range(n):
    if not is_perfect_square(a[i]):
        ans = max(ans, a[i])

print(ans)
```
CODEFORCES 936_C. Lock Puzzle
```
1
a
b
```

```
2
aa
ab
```

```
3
aaa
bbb
```

```
4
abab
baba
```

```
5
abacaba
acababa
```

```
6
abacbb
babcba
```

```
7
abababa
abababa
```

```
8
aaaaaaaa
aaaaaaaa
```
CODEFORCES 962_A. Equator
```
1
1
```
```
4
1 3 2 1
```
```
6
2 2 2 2 2 2
```
```
10
1 2 3 4 5 6 7 8 9 10
```
```
100000
100000
```
```
100000
1 1 1 1 1 1 1 1 1 1
```
```
100000
100000 100000
```
```
100000
100000 100000 100000
```
```
50000
99999 99999 99999 99999 99999 99999 99999 99999 99999 99999
```
```
200000
99999 99999 99999 99999 99999 99999 99999 99999 99999 99999 99999 99999 99999 99999 99999 99999 99999 99999 99999 99999 99999 99999 99999 99999 99999 99999 99999 99999
```
CODEFORCES 98_B. Help King
```
1
2
3
4
-1
```
HACKEREARTH andrew-and-wengaluru-city
```
1
1
4
```
HACKEREARTH chacha-chaudhary-and-sabu
1
2 1 2 2 15
HACKEREARTH diedie
```
1
3
```
HACKEREARTH generate-composite-numbers
```
1
2
3
4
5
6
7
8
9
10
```
HACKEREARTH least-common-multiple
1. **Incorrect implementation of the LCM algorithm.**

```
def lcm(a, b):
  if a == 0:
    return b
  if b == 0:
    return a
  return a * b // gcd(a, b)
```

This implementation of the LCM algorithm is incorrect because it uses the wrong base case. The base case for the LCM algorithm should be when one of the inputs is 0, in which case the LCM is equal to the other input.

```
def lcm(a, b):
  if a == 0:
    return b
  if b == 0:
    return a
  return a * b
```

This implementation of the LCM algorithm is correct.

2. **Incorrect handling of negative integers.**

```
n = int(input())
print(lcm(n, n + 1))
```

This program will crash if `n` is negative because the LCM algorithm does not work correctly for negative integers.

```
n = int(input())
if n < 0:
  print("Invalid input")
else:
  print(lcm(n, n + 1))
```

This program will correctly handle negative integers.

3. **Incorrect handling of floating-point numbers.**

```
n = float(input())
print(lcm(n, n + 1))
```

This program will crash if `n` is a floating-point number because the LCM algorithm does not work correctly for floating-point numbers.

```
n = int(input())
print(lcm(n, n + 1))
```

This program will correctly handle floating-point numbers.

4. **Incorrect handling of large integers.**

```
n = 10**15
print(lcm(n, n + 1))
```

This program will be very slow for large integers because the LCM algorithm is recursive, and each recursive call requires multiplying two integers. For large integers, this multiplication can be very time-consuming.

```
n = 10**15
print(lcm(n, n + 1))
```

This program will correctly handle large integers, but it will be very slow.

5. **Incorrect handling of overflow.**

```
n = 2**64
print(lcm(n, n + 1))
```

This program will crash for large integers because the LCM algorithm can overflow for large integers.

```
n = 2**63 - 1
print(lcm(n, n + 1))
```

This program will correctly handle large integers without overflowing.

6. **Incorrect handling of division by zero.**

```
n = 0
print(lcm(n, n + 1))
```

This program will crash because the LCM algorithm can divide by zero if one of the inputs is 0.

```
n = 1
print(lcm(n, n + 1))
```

This program will correctly handle division by zero.

7. **Incorrect handling of invalid inputs.**

```
n = "abc"
print(lcm(n, n + 1))
```

This program will crash because the LCM algorithm assumes that both inputs are positive integers. If either of the inputs is invalid, the LCM algorithm will crash.

```
n = 1
print(lcm(n, n + 1))
```

This program will correctly handle invalid inputs.
HACKEREARTH monk-in-the-grass-fields
```
2
2 1
1 3
3 2
1 3
2 4
```
HACKEREARTH permutations
1. **Incorrect input format.**

```
1
2
```

2. **Incorrect use of the `swap()` function.**

```
3
1 2 3
NYN
YNY
NYN
```

3. **Incorrect use of the `min()` function.**

```
3
1 2 3
NYN
YNY
NNN
```

4. **Incorrect use of the `sort()` function.**

```
3
1 2 3
NYN
YNY
NNN
```

5. **Incorrect use of the `print()` function.**

```
3
1 2 3
NYN
YNY
NNN
```
HACKEREARTH roy-and-ring-13
```
1
1000000000
```

```
1
1000000001
```

```
2
1 2
```
HACKEREARTH subpalindrome-2
1. a
2. aa
3. b
4. ab
5. abc
6. aba
7. abba
8. abb
9. ababa
10. abab
HACKEREARTH vanya-and-gcd-array
```
1
100
```
ATCODER p02605 M-SOLUTIONS Programming Contest 2020 - Air Safety
```
2
11 1 U
11 47 D
```
```
4
20 30 U
30 20 R
20 10 D
10 20 L
```
```
8
168 224 U
130 175 R
111 198 D
121 188 L
201 116 U
112 121 R
145 239 D
185 107 L
```
```
2
100000 100000 U
100000 100000 D
```
ATCODER p02736 AtCoder Grand Contest 043 - 123 Triangle
```
4
1231
```

```
10
2311312312
```

```
1000000
1234321234321
```
ATCODER p02870 NIKKEI Programming Contest 2019-2 - Mirror Frame
4
o?o
???
?x?

ATCODER p03005 diverta 2019 Programming Contest 2 - Ball Distribution
1
1
3
2
8
5
ATCODER p03145 AtCoder Beginner Contest 116 - Right Triangle
1. Incorrect input format:
```
3 4 5 6
```
2. Incorrect data type:
```
3.14 4 5
```
3. Malformed input:
```
3,4,5
```
4. Insufficient input:
```
3
```
5. Excessive input:
```
3 4 5 6 7
```
6. Incorrect output format:
```
6.0
```
7. Incorrect data type:
```
6.0
```
8. Malformed output:
```
6,0
```
ATCODER p03289 AtCoder Beginner Contest 104 - AcCepted
```
AtCoder
```
```
ACoder
```
```
AcycliC
```
```
AtCoCo
```
```
Atcoder
```
ATCODER p03445 AtCoder Petrozavodsk Contest 001 - Simple APSP Problem
```
2 3
1
1 1
```

```
2 3
1
1 2
```

```
3 3
1
1 1
```

```
4 4
4
0 1
1 1
2 1
2 2
```

```
1000000 1000000
1
0 0
```
ATCODER p03605 AtCoder Beginner Contest 073 - September 9
10
29
99
ATCODER p03766 AtCoder Regular Contest 071 - Infinite Sequence
```
2
654321
```
ATCODER p03934 square869120Contest #3 - Sushi
```
9 3
5 11
8 4
4 7
```
AIZU p00027 What day is today?
1 2
2 29
2 28
0 0
AIZU p00158 Collatz's Problem
```
-1
1000001
-10
3
10
1000000
0
```
AIZU p00315 Quality Management
**Incorrect**

```
1 6
000000
000000
010010
010010
000000
000000
```

**Incorrect**

```
1 6
000000
000000
001001
001001
000000
000000
```

**Incorrect**

```
1 6
000000
000000
000000
000000
000000
000000
```

**Incorrect**

```
1 6
000000
000000
010010
001001
000000
000000
```

**Correct**

```
7 8
00100000
00011000
10111101
01100110
01000110
10111101
00011000
00100100
2
5 3
1 6
1
6 8
3
6 8
3 3
3 6
2
6 3
6 6
0
2
3 8
6 8
```
AIZU p00485 Shopping in JOI Kingdom
**Incorrect input format**

```
1 2 1
1 2 1
1
1
```

**Incorrect data type**

```
1 2 1
1 2 1.0
1
1
```

**Undefined behavior**

```
1 2 1
1 2 1
1
0
```

**Memory leaks**

```
1 2 1
1 2 1
1
1
```

**Security vulnerabilities**

```
1 2 1
1 2 1
1
1
```
AIZU p00671 Live Schedule
```
5 5 10 2
1 1 0 1 1
0 9 1 0 1
1 1 1 9 1
1 1 9 0 1
1 1 1 1 0
1 1 0 1 1
0 9 1 0 1
1 1 1 9 1
1 1 1 0 1
1 1 1 1 0
1 1 10 0
3
7
1 1 5 0
3
6
1 2 10 1
6 7
5 6
2 1 10 1
4
8
3
7
2 1 10 0
4
8
3
7
2 1 5 0
4
8
3
6
0 0 0 0
```
AIZU p00814 Life Line
```
4 4
2
2 3
1 0 4
1 1 4 0
4 5
2
2 3
3 0 4
1 1 4 0
4 1
2
2 3
3 0 4
1 1 4 0
4 1
1
1 1
1 1 1
1 1 1 0
4 2
1
1 1
1 1 1
1 1 1 0
4 1
0
2 2
5 0 7
0 5 7 0
4 2
0
0 3
1 0 4
0 1 0 4
4 3
0
3 3
3 2 3
0 3 0 3
4 2
0
3 3
3 2 3
0 3 0 3
6 1
1
1 2
1 1 0
6 7 6 8
0 7 6 8 2
6 6 7 2 2 0
5 9
0
0 0
0 0 0
0 0 0 0
0 0 0 0 0
5 3
3
3 2
4 3 2
4 4 0 3
3 3 3 0 3
0 0
```
AIZU p00945 Min-Max Distance Game
1. **Off-by-one errors**

```
Input:

5 Alice
10 20 30 40 50


Output:

31
```

2. **Incorrect boundary conditions**

```
Input:

5 Alice
-10 20 30 40 50


Output:

30
```

3. **Incorrect data types**

```
Input:

5 Alice
"10" "20" "30" "40" "50"


Output:

30
```

4. **Logical errors**

```
Input:

5 Alice
10 10 10 10 10


Output:

10
```

5. **Runtime errors**

```
Input:

100000 Alice
1 2 3 4 5 ... 100000


Output:

100000
```
AIZU p01078 Star
5 2
20 3
7 3
100000 3
1 3
10 100
100000 100000
5 1000000000
1000000000 1000000000
AIZU p01212 Mysterious Dungeons
```
8 3
########
#<A.@.a#
########
8 3
########
#<AaAa@#
########
8 4
########
#<EeEe@#
#FG.e#.#
########
8 8
########
#mmm@ZZ#
#mAAAbZ#
#mABBBZ#
#mABCCd#
#aABCDD#
#ZZcCD<#
########
0 0
```
AIZU p01348 Cruel Bingo
```
# 1. Incorrect input format
1 0

# 2. Incorrect output format
4 2
0 2
3 1
0

# 3. Incorrect calculation
4 2
0 2
3 1
4294967295

# 4. Off-by-one error
4 2
0 2
3 1
5

# 5. Memory overflow
1000000000 1000000000

# 6. Timeout
10 1000000000

# 7. Incorrect algorithm
4 2
0 2
3 1
20

# 8. Incorrect data structure
4 2
0 2
3 1
6

# 9. Incorrect implementation
4 2
0 2
3 1
4294967295

# 10. Incorrect testing
4 2
0 2
3 1
6
AIZU p01530 XOR Cloister
```
5 5 3
0 1 7
1 2 22
2 3 128
3 4 128
4 2 128
0 1
0 0
3 4
```
AIZU p01686 Magical Switches

AIZU p01830 Delete Files
1. 
```
2
y 7
n 6
```
2. 
```
2
y 7
y 6
```
3. 
```
2
n 7
n 6
```
4. 
```
4
y 7
y 6
y 5
y 4
```
5. 
```
4
y 7
y 6
y 5
y 4
```
AIZU p01965 Farm Village
```
# 1. Incorrect input format.
1
1 2
1 1

# 2. Incorrect data type.
2
1 2
1 1.1

# 3. Off-by-one error.
3
1 2 3
1 1 100 100

# 4. Incorrect algorithm.
5
1 2 3 4 5
1 1 1 1 1

# 5. Memory leak.
5
1 2 3 4 5
1 1 1 1 1

# 6. Race condition.
5
1 2 3 4 5
1 1 1 1 1

# 7. Null pointer exception.
5
1 2 3 4 5
1 1 1 1 1

# 8. Stack overflow.
5
1 2 3 4 5
1 1 1 1 1

# 9. Divide by zero error.
5
1 2 3 4 5
1 0 1 1 1

# 10. Arithmetic overflow error.
5
2147483647 2147483647 2147483647 2147483647 2147483647
1 1 1 1 1
```
AIZU p02112 Hating Crowd
1
1 1 359 1

2
2 4 25 306
1 9 7 321

8
2 9 297 297
8 6 359 211
8 16 28 288
7 9 113 143
3 18 315 190
10 18 277 300
9 5 276 88
3 5 322 40
AIZU p02252 Fractional Knapsack Problem
1. ```
N,W=map(int,input().split())
v,w=[0]*N,[0]*N
for i in range(N):
    v[i],w[i]=map(int,input().split())
dp=[0]*(W+1)
for i in range(N):
    for j in range(W,-1,-1):
        if j>=w[i]:
            dp[j]=max(dp[j],dp[j-w[i]]+v[i])
print(dp[W])
```


2. ```
N,W=map(int,input().split())
v,w=[0]*N,[0]*N
for i in range(N):
    v[i],w[i]=map(int,input().split())
dp=[0]*(W+1)
for i in range(N):
    for j in range(W,-1,-1):
        if j>=w[i]:
            dp[j]=max(dp[j],dp[j-w[i]]+v[i])
print(round(dp[W],6))
```


3. ```
N,W=map(int,input().split())
v,w=[0]*N,[0]*N
for i in range(N):
    v[i],w[i]=map(int,input().split())
dp=[0]*(W+1)
for i in range(N):
    dp[w[i]]=max(dp[w[i]],v[i])
for i in range(1,W+1):
    dp[i]=max(dp[i],dp[i-1])
for i in range(N-1,-1,-1):
    for j in range(W,-1,-1):
        if j>=w[i]:
            dp[j]=max(dp[j],dp[j-w[i]]+v[i])
print(round(dp[W],6))
```


4. ```
N,W=map(int,input().split())
v,w=[0]*N,[0]*N
for i in range(N):
    v[i],w[i]=map(int,input().split())
dp=[0]*(W+1)
for i in range(N):
    for j in range(W,w[i]-1,-1):
        dp[j]=max(dp[j],dp[j-w[i]]+v[i])
print(round(dp[W],6))
```


5. ```
N,W=map(int,input().split())
v,w=[0]*N,[0]*N
for i in range(N):
    v[i],w[i]=map(int,input().split())
dp=[0]*(W+1)
for i in range(N):
    for j in range(W,w[i]-1,-1):
        dp[j]=max(dp[j],dp[j-w[i]]+v[i])
print(round(dp[W],6))
```
AIZU p02400 Circle
0

-2

1

2

3

4

5

10

100

1000