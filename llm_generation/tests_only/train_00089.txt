CODECHEF capple
```
1
3
3 3 3

2
3
1 2 3

3
4
1 2 3 3

4
3
1 2 3

5
3
1 1 1

6
4
1 1 1 1

7
4
1 2 1 1

8
5
1 1 2 3 4

9
5
2 2 3 4 5

10
5
1 2 3 4 5
```
CODECHEF craft05
1
5
1 2 3

3
1
5 5 5

1
1
0 0 0
CODECHEF greedy
1
1000000 1000000
CODECHEF maxisum
```
1
3 1
1 2 3
4 5 6
```
CODECHEF rbx12r02
```
1
6 5 3
```
```
2
4 2 3
4 5 4
```
```
1
1000000 1 1
```
CODECHEF tourmap
1
5
Warsaw Kiev 120$
Madrid Paris 100$
Munich Warsaw 150$
Paris Munich 200$
CODEFORCES 1015_F. Bracket Substring
**Incorrect input format**

```
5
(((())
```

**Incorrect output format**

```
5
```

**Incorrect calculation**

```
5
())
```

**Memory leaks**

```
5
())
```

**Race conditions**

```
5
())
```

**Deadlocks**

```
5
())
```

**Buffer overflows**

```
5
())
```

**Integer overflows**

```
5
())
```

**Floating-point errors**

```
5
())
```

**Security vulnerabilities**

```
5
())
```
CODEFORCES 1039_E. Summer Oenothera Exhibition
```
3 6 5
2 4 0
1 2 3 4 5
```
CODEFORCES 1062_A. A Prank
```
1
0
```

```
2
1 1
```

```
1
-1
```

```
100
1 1 1 1 1 1 1 1 1 1
```

```
100
1000 999 998 997 996 995 994 993 992 991
```

```
100
999 998 997 996 995 994 993 992 991 1
```

```
100
1000 999 998 997 996 995 994 993 992 991 990 989 988 987 986 985 984 983 982
```
CODEFORCES 1083_F. The Fair Nut and Amusing Xor
```
3 3 1
0 4 2
1 2 3
b 2 5

3 2 2
1 3 2
0 0 0
a 1 0
b 1 1
```
CODEFORCES 1103_B. Game with modulo
```
# Codeforces 1103_B. Game with modulo

# 1. Not understanding the problem statement.

start
x
x

# 2. Making a mistake in your implementation.

start
? 0 0
? 10 1
! 1

# 3. Running out of time.

start
? 0 0
? 10 1
! 1

# 4. Getting the wrong answer.

start
? 0 0
? 10 1
! 3
```
CODEFORCES 1131_B. Draw!
1. ```
1
5 4
```
2. ```
3
0 0
0 0
0 0
```
3. ```
1
10000 10000
```
CODEFORCES 1151_D. Stas and the Queue at the Buffet
1. Incorrect input format

```
1
2 3
```

2. Incorrect data type

```
1
a 3
```

3. Incorrect algorithm

```
n = int(input())
a, b = [], []
for _ in range(n):
    a.append(int(input()))
    b.append(int(input()))

ans = 0
for i in range(n):
    ans += a[i] * (i - 1) + b[i] * (n - i)
print(ans)
```

This algorithm will produce incorrect output for inputs such as `1` and `1 2`.

4. Incorrect implementation

```
n = int(input())
a, b = [], []
for _ in range(n):
    a.append(int(input()))
    b.append(int(input()))

ans = 0
for i in range(n):
    ans += a[i] * (n - i) + b[i] * (i - 1)
print(ans)
```

This implementation will produce incorrect output for inputs such as `1` and `1 2`.

5. Runtime errors

```
n = int(input())
a, b = [], []
for _ in range(n):
    a.append(int(input()))
    b.append(int(input()))

ans = 0
for i in range(n):
    ans += a[i] * (i - 1) + b[i] * (n - i)
print(ans)
```

This program will run into a runtime error if the input is too large.

6. Logical errors

```
n = int(input())
a, b = [], []
for _ in range(n):
    a.append(int(input()))
    b.append(int(input()))

ans = 0
for i in range(n):
    ans += a[i] * (n - i) + b[i] * (n - i)
print(ans)
```

This program will produce incorrect output because it is adding the dissatisfaction for each person twice.
CODEFORCES 1173_C. Nauuo and Cards
```
3
0 2 0
3 0 1

3
0 2 0
1 0 3

11
0 0 0 5 0 0 0 4 0 0 11
9 2 6 0 8 1 7 0 3 0 10
```
CODEFORCES 1190_F. Tokitsukaze and Powers
```
1 2 1
3 5 1
2 5 4
4 9 8
3 100 7
```
CODEFORCES 1209_H. Moving Walkways
```
1 5
0 2 2.0
```

```
1 5
2 4 0.91
```

```
3 1000
0 990 1.777777
995 996 1.123456789
996 1000 2.0
```

```
100 1000000
990000 999999 0.000001
```

```
500 1000000
990000 999999 0.000001
```

```
1000000 1000000000
0 1000000000 1.0
```
CODEFORCES 122_C. Lucky Sum
```
2 7
7 7
1 1000000000
```
CODEFORCES 1251_B. Binary Palindromes
```
1
1
0
```

```
3
4
111111
000000
111111
```

```
3
2
101
010
```

```
4
5
001111
000001
11100111
11100111
```

```
1
10010
```

```
1
1
```

```
1
110011
```

```
3
3
1110
11110
10110
```

```
1
0
```

```
1
11111
```
CODEFORCES 1270_I. Xor on Figures
```
1
1
3
2
3
1
2
2
```
CODEFORCES 1294_A. Collecting Coins
```
1
100 101 102 105
```
CODEFORCES 1315_A. Dead Pixel
1. **Incorrect input format**
```
1
5 5 0 0
```
2. **Incorrect output format**
```
1
5 5 0 0
```
3. **Off-by-one error**
```
1
5 5 0 0
```
4. **Incorrect boundary conditions**
```
1
5 5 0 0
```
5. **Logic error**
```
1
5 5 0 0
```
6. **Runtime error**
```
1
5 5 0 0
```
CODEFORCES 1336_D. Yui and Mahjong Set
```
1
0
```
CODEFORCES 1359_A. Berland Poker
```
3
3 1 2
2 2 2
2 1 2
```
CODEFORCES 1379_C. Choosing flowers
```
1
5 3
5 0
1 4
2 2
```
```
2
4 3
5 0
1 4
2 2

5 3
5 2
4 2
3 1
```
```
1
10 10
1 1000000000
2 1000000000
3 1000000000
4 1000000000
5 1000000000
6 1000000000
7 1000000000
8 1000000000
9 1000000000
10 1000000000
```
```
2
5 3
5 2
4 2
3 1

5 3
5 2
4 2
3 1
```
```
4
1 3
1 5
2 3
3 1

5 3
5 2
4 2
3 1

10 10
1 1000000000
2 1000000000
3 1000000000
4 1000000000
5 1000000000
6 1000000000
7 1000000000
8 1000000000
9 1000000000
10 1000000000
```
```
10
10 10
1 1000000000
2 1000000000
3 1000000000
4 1000000000
5 1000000000
6 1000000000
7 1000000000
8 1000000000
9 1000000000
10 1000000000
```
CODEFORCES 139_A. Petr and Book
```
# 1. Incorrect input format

n = int(input())
pages = [int(x) for x in input().split()]

# 2. Incorrect output format

print(1)

# 3. Incorrect calculation of the number of pages Petr can read each day

n = int(input())
pages = [int(x) for x in input().split()]

total_pages = 0
for page in pages:
    total_pages += page

print(total_pages)

# 4. Incorrect logic for determining the day on which Petr will finish reading the book

n = int(input())
pages = [int(x) for x in input().split()]

total_pages = 0
for page in pages:
    total_pages += page

if total_pages <= n:
    print(1)
else:
    print(7)

# 5. Incorrect error handling

n = int(input())
pages = [int(x) for x in input().split()]

if n == 0:
    raise ValueError('n must be greater than 0')

for page in pages:
    if page < 0:
        raise ValueError('pages must be non-negative')
```
CODEFORCES 1423_E. 5G Antenna Towers
```
10 10 3
4 2 2 3 2 3 3 2 3
3 3.5 2 4.5 2 4.5 3
4 7 8 7.5 8.5 8 8 7.5 9
5
2 3.5 0.5
3.3 2 0.4
5 2.5 0.5
7.5 8.5 0.5
3 7 0.5
```
CODEFORCES 1442_D. Sum
```
1 1
1 10
```

```
1 2
1 10
```

```
2 2
2 1 2
2 1 2
```

```
3 3
2 5 10
3 1 2 3
2 1 20
```

```
3 4
2 5 10
3 1 2 3
2 1 20
```

```
4 4
2 5 10
3 1 2 3
2 1 20
```

```
1 100000
100000 100000
```

```
10 100000
100000 100000
```
CODEFORCES 1468_F. Full Turn
```
1
3
0 0 1 1
1 1 0 0
1 0 2 0
```

```
1
3
0 0 1 1
1 1 0 0
1 0 2 0
```

```
1
3
0 0 1 1
1 1 0 0
1 0 2 0
```

```
1
3
0 0 1 1
1 1 0 0
1 0 2 0
```

```
1
3
0 0 1 1
1 1 0 0
1 0 2 0
```
CODEFORCES 1492_E. Almost Fault-Tolerant Database
2 3
1 2 3
4 5 6

2 4
1 10 10 100
1 1 1 100

5 7
1 1 1 1 1 1 1
1 1 1 1 1 1 2
1 1 1 1 1 2 2
1 1 1 1 2 2 1
1 1 1 2 2 1 1
1 2 2 1 1 1 1

5 7
1 1 1 1 1 1 1
1 1 1 1 1 1 2
1 1 1 1 1 2 2
1 1 1 1 2 2 1
1 1 1 2 2 1 1
1 2 2 1 1 1 1
CODEFORCES 1515_F. Phoenix and Earthquake
1. Incorrect input format

```
5 4 1
0 0 0 4 0
1 2
2 3
3 4
4 5
```

This input is incorrect because the number of cities `n` is not a positive integer.

2. Incorrect output format

```
YES
1
2
3
4
```

This output is incorrect because it does not have the correct format. The output should be a string followed by a list of integers.

3. Incorrect algorithm

```
def find_roads(n, m, x):
  """Finds the roads that need to be repaired to connect all the cities.

  Args:
    n: The number of cities.
    m: The number of roads.
    x: The amount of asphalt needed to repair one road.

  Returns:
    A list of the indices of the roads that need to be repaired.
  """

  # Create a graph of the roads.
  graph = {}
  for i in range(1, n + 1):
    graph[i] = []
  for i in range(m):
    x, y = map(int, input().split())
    graph[x].append(y)
    graph[y].append(x)

  # Find the minimum amount of asphalt needed to connect all the cities.
  min_asphalt = float("inf")
  for i in range(n):
    for j in graph[i]:
      if i < j and min_asphalt > a[i] + a[j] - x:
        min_asphalt = a[i] + a[j] - x

  # Find the roads that need to be repaired.
  roads = []
  for i in range(n):
    for j in graph[i]:
      if i < j and a[i] + a[j] - x == min_asphalt:
        roads.append(i)
        roads.append(j)

  return roads


n, m, x = map(int, input().split())
a = list(map(int, input().split()))
roads = find_roads(n, m, x)

if len(roads) == n - 1:
  print("YES")
  for road in roads:
    print(road + 1, end=" ")
  print()
else:
  print("NO")
```

This algorithm is incorrect because it does not correctly find the roads that need to be repaired.

4. Incorrect implementation

```
def find_roads(n, m, x):
  """Finds the roads that need to be repaired to connect all the cities.

  Args:
    n: The number of cities.
    m: The number of roads.
    x: The amount of asphalt needed to repair one road.

  Returns:
    A list of the indices of the roads that need to be repaired.
  """

  # Create a graph of the roads.
  graph = {}
  for i in range(1, n + 1):
    graph[i] = []
  for i in range(m):
    x, y = map(int, input().split())
    graph[x].append(y)
    graph[y].append(x)

  # Find the minimum amount of asphalt needed to connect all the cities.
  min_asphalt = float("inf")
  for i in range(n):
    for j in graph[i]:
      if i < j and min_asphalt > a[i] + a[j] - x:
        min_asphalt = a[i] + a[j] - x

  # Find the roads that need to be repaired.
  roads = []
  for i in range(n):
    for j in graph[i]:
      if i < j and a[i] + a[j] - x == min_asphalt:
        roads.append((i, j))

  return roads


n, m, x = map(int, input().split())
a = list(map(int, input().split()))
roads = find_roads(n, m, x)

if len(roads) == n - 1:
  print("YES")
  for i, j in roads:
    print(i + 1, j +
CODEFORCES 1542_E1. Abnormal Permutation Pairs (easy version)
```
1 1
5 10
5 1000000007
```
CODEFORCES 16_E. Fish
```
1
1.0
```

```
2
0.5 0.5
```

```
2
0.3 0.7
```

```
2
1.0 0.0
```

```
3
0.5 0.5 0.5
```

```
4
0.5 0.5 0.5 0.5
```

```
5
0 1 1 1 1
```

```
5
0.5 0.5 0.5 0.5 0.5
```

```
5
0 0.5 0.5 0.5 0.5
```

```
5
0.5 0 0.5 0.5 0.5
```

```
5
0.5 0.5 0 0.5 0.5
```

```
5
0.5 0.5 0.5 0 0.5
```

```
5
0.5 0.5 0.5 0.5 0
```
CODEFORCES 190_C. STL
```
1
pair int

10
pair int int int int int int int int int int

2
pair int int

4
pair pair int int
```
CODEFORCES 214_C. Game
```
# 214C. Game

def dfs(i, path):
    if i == 0:
        return 0
    for j in range(1, n + 1):
        if a[i][j] == 1:
            if j in path:
                continue
            path.append(j)
            cost = dfs(j, path) + 1
            path.pop()
            if cost < ans:
                ans = cost
    return ans


n = int(input())
c = list(map(int, input().split()))
a = [[0] * (n + 1) for _ in range(n + 1)]
for i in range(n):
    k = int(input())
    for j in range(k):
        u, v = map(int, input().split())
        a[u][v] = 1
        a[v][u] = 1
ans = float('inf')
path = [0]
dfs(n, path)
print(ans)
```

Incorrect input format:
```
1
1
```

Incorrect data type:
```
1
1
1
```

Off-by-one errors:
```
1
2 3 1
1 2
2 1
```

Logic errors:
```
1
1
1
```

Memory leaks:
```
1
1
1
```

Security vulnerabilities:
```
1
1
1
```
CODEFORCES 238_C. World Eater Brothers
1. **Incorrect input format**

```
1
```

```
2
1 2
```

```
3
1 2
2 3
```

2. **Incorrect output format**

```
4
```

```
-1
```

```
0.5
```

3. **Incorrect logic**

```
4
1 2
2 3
3 4
```

```
2
```

```
5
1 2
2 3
3 4
4 5
```

```
1
```

4. **Runtime error**

```
1000000000
```

```
1000000000000000
```

5. **Security vulnerability**

```
```
CODEFORCES 263_A. Beautiful Matrix
```
0 0 0 0 0
0 0 0 0 1
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0

0 0 0 0 0
0 0 0 0 0
0 1 0 0 0
0 0 0 0 0
0 0 0 0 0

1 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0

0 1 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0

0 0 0 0 0
0 0 0 0 1
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0

0 0 0 0 0
0 1 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0

0 1 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0

0 0 0 0 0
0 0 0 0 0
0 0 1 0 0
0 0 0 0 0
0 0 0 0 0

0 0 0 0 0
0 0 0 0 0
0 0 0 0 1
0 0 0 0 0
0 0 0 0 0

0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 1 0 0
0 0 0 0 0
```
CODEFORCES 287_A. IQ Test
```
####
....
####
....

```

```
####
.#..
####
....
```
CODEFORCES 312_A. Whose sentence is it?
1
Freda's

2
miao.
miao.

3
Freda's
Rainbow's
Rainbow's

4
miao.Freda's
miao.Freda's
miao.Freda's
miao.Freda's
CODEFORCES 334_D. Chips
3 1
2 2

3 0

4 3
3 1
3 2
3 3

CODEFORCES 357_D. Xenia and Hamming
```
1 1
a
a
```

```
100 10
a
aaaaaaaaaa
```

```
1 1
abacaba
abzczzz
```

```
2 3
rzr
az
```

```
1 3
b
ab
```

```
5 5
a
b
```

```
10 10
1234567890
1234567890
```

```
1 100
a
b
```

```
100 1
a
1234567890
```

```
50 50
a
b
```
CODEFORCES 380_C. Sereja and Brackets
```
())(())(())(
7
1 1
2 3
1 2
1 12
8 12
5 11
2 10
```
CODEFORCES 401_B. Sereja and Contests
```
3 2
2 1
2 2
```

```
9 3
1 2 3
2 8
1 4 5
```

```
10 0
```
CODEFORCES 429_C. Guess the Tree
```
1
1
```

```
2
2 2
```

```
3
1 1 1
```

```
4
1 1 1 4
```

```
5
1 1 5 2 1
```

```
6
1 1 1 1 1 1
```
CODEFORCES 451_A. Game With Sticks
1. **Incorrect input format.**

```
1 2
```

2. **Incorrect output format.**

```
Akshat Malvika
```

3. **Incorrect calculation of the number of intersection points.**

```
1 3
```

4. **Incorrect choice of the first move.**

```
2 2
```

5. **Incorrect gameplay.**

```
3 3
```
CODEFORCES 472_G. Design Tutorial: Increase the Constraints
```
101010
11110000
3
0 0 3
2 3 4
5 7 1
```
CODEFORCES 497_C. Distributing Parts 
```
3
1 3
2 4
3 5
2
1 4 2
2 5 1
```
CODEFORCES 520_E. Pluses everywhere
**Incorrect input format**

```
1 10
a
```

**Incorrect output format**

```
10
```

**Incorrect logic**

```
3 2
108
```

**Memory leaks**

```
n = int(input())
s = input()
while n:
    print(int(s[:n]), end='')
    n -= 1
```

**Race conditions**

```
n = int(input())
s = input()
def add_plus(s, i):
    if i == 0 or i == len(s) - 1:
        return s
    else:
        return s[:i] + '+' + s[i + 1:]

ans = 0
for i in range(len(s)):
    ans += add_plus(s, i)
print(ans % 109 + 7)
```

**Security vulnerabilities**

```
import requests

n = int(input())
s = input()

url = 'http://localhost:8000/pluses'
data = {'n': n, 's': s}
r = requests.post(url, data=data)
print(r.text)
```
CODEFORCES 548_B. Mike and Fun
```
5 4 5
0 1 1 0
1 0 0 1
0 1 1 0
1 0 0 1
0 0 0 0
1 1
1 4
1 1
4 2
4 3
```
CODEFORCES 574_D. Bear and Blocks
```
1
1
```

```
2
1 1
```

```
3
1 2 1
```

```
4
1 2 1 2
```

```
5
1 2 1 2 1
```

```
6
1 2 3 4 5 6
```

```
7
2 1 4 6 2 2
```

```
8
2 1 2 3 4 5 6 7
```

```
9
1 1 1 1 1 1 1 1
```

```
10
1 1 1 1 1 1 1 1 1
```
CODEFORCES 596_B. Wilbur and Array
1. Incorrect input format
```
5
1 2 3 4 5
```

2. Incorrect output format
```
5
1 2 2 1
```

3. Incorrect calculation
```
5
1 2 3 4 5
```

4. Incorrect data structures
```
5
1 2 3 4 5
```

5. Incorrect error handling
```
5
1 2 3 4 5
```

6. Incorrect testing
```
5
1 2 3 4 5
```
CODEFORCES 617_D. Polyline
```
1 1
2 2
3 3
```

```
1 1
2 3
4 3
```

```
1 1
2 3
3 2
```

```
1 1
2 2
3 3
4 4
```

```
-1 -1
-1 3
4 3
```

```
-1 -1
-1 3
4 3
```
CODEFORCES 638_A. Home Numbers
1. ```
1 1
```
2. ```
2 2
```
3. ```
4 2
```
4. ```
8 5
```
5. ```
10 7
```
6. ```
100000 50000
```
CODEFORCES 665_E. Beautiful Subarrays
```
3 1
1 2 3
```

```
3 2
1 2 3
```

```
3 3
1 2 3
```

```
4 4
1 2 3 4
```

```
10 10
1 2 3 4 5 6 7 8 9 10
```
CODEFORCES 68_C. Synchrophasotron
```
2
1 2 1 2 3
```

```
3
1 2 1 2 3
1 3 0 0 0
2 3 3 4 5
```

```
5
1 2 0 2 1
2 3 0 2 1
1 3 0 2 6
1 4 0 0 1
2 4 0 0 0
3 4 2 3 0
```

```
3
1 2 0 2 1
1 3 1 2 1
2 3 1 2 1
```

```
4
1 2 1 2 1
1 3 1 2 1
2 3 1 2 1
3 4 1 2 1
```

```
5
1 2 0 2 1
1 3 0 2 1
2 3 0 2 1
3 4 0 2 1
4 5 0 2 1
```

```
6
1 2 1 2 1
1 3 0 2 1
2 3 0 2 1
3 4 0 2 1
4 5 0 2 1
5 6 0 2 1
```
CODEFORCES 712_A. Memory and Crow
```
5
6 -4 8 -2 3

5
3 -2 -1 5 6
```
CODEFORCES 732_F. Tourist Reform
**Incorrect input format**

```
1 1
```

**Incorrect data**

```
2 1
1 1
```

**Undefined behavior**

```
5 5
1 2
2 3
3 4
4 5
5 1
```

**Time complexity**

```
1000000000 1000000000
```

**Space complexity**

```
1000000000
```

**Correctness**

```
1 1
```

**Robustness**

```
1 1
```

**Maintainability**

```
1 1
```
CODEFORCES 757_A. Gotta Catch Em' All!
```
aBddulbasaurrgndgbualdBdsagaurrgndbb

Bulbbasaur

F
```
CODEFORCES 778_C. Peterson Polyglot
```
5
1 2 c
2 3 a
3 4 t
2 5 t
```
CODEFORCES 802_F. Marmots (hard)
```
# Sample input 1

3
1
1 3 2

# Sample output 1

uniform

# Sample input 2

3
2
1 2 3

# Sample output 2

poisson

# Sample input 3

3
3
-1 1 3

# Sample output 3

poisson

# Sample input 4

10
1
1 2 3 4 5 6 7 8 9 10

# Sample output 4

uniform

# Sample input 5

10
10
-10 10 -9 9 -8 8 -7 7 -6 6 -5 5 -4 4 -3 3 -2 2 -1 1

# Sample output 5

uniform
```
CODEFORCES 825_B. Five-In-a-Row
```
# Input

XX.XX.....
.....OOOO.
..........
..........
..........
..........
..........
..........
..........
..........

# Output

YES
```

```
# Input

XXOXX.....
OO.O......
..........
..........
..........
..........
..........
..........
..........
..........

# Output

NO
```

```
# Input

XXXX....
....XXXX
....XXXX
....XXXX
....XXXX
....XXXX
....XXXX
....XXXX
....XXXX

# Output

NO
```

```
# Input

XX.X.X...
.X.X.X...
.X.X.X...
.X.X.X...
.X.X.X...
.X.X.X...
.X.X.X...
.X.X.X...
.X.X.X...

# Output

YES
```
CODEFORCES 847_M. Weather Tomorrow
1. ```
2
1 2
```
2. ```
1
1000
```
3. ```
3
1 2 3
```
4. ```
4
1000 1001 1002 1003
```
5. ```
5
1000 1001 1002 1003 1004
```
6. ```
10
1 2 3 4 5 6 7 8 9 10
```
7. ```
10
10 9 8 7 6 5 4 3 2 1
```
8. ```
10
-1 0 1 2 3 4 5 6 7 8
```
9. ```
10
-8 -7 -6 -5 -4 -3 -2 -1 0 1
```
10. ```
10
-10 -10 -10 -10 -10 -10 -10 -10 -10 -10
```
CODEFORCES 86_C. Genetic engineering
```
# 1. Incorrect data type

2 1
A

# 2. Off-by-one errors

5 2
A
C

# 3. Incorrect use of pointers

5 2
A
C

# 4. Memory leaks

5 2
A
C

# 5. Race conditions

5 2
A
C

# 6. Deadlocks

5 2
A
C

# 7. Security vulnerabilities

5 2
A
C

# 8. Performance problems

5 2
A
C

# 9. Unmaintainable code

5 2
A
C

# 10. Undocumented code

5 2
A
C
```
CODEFORCES 896_B. Ithea Plays With Chtholly
### Incorrect input format

```
# Problem: Ithea Plays With Chtholly
# Author: Daniil Oleynik

n, m, c = map(int, input().split())
ans = []

for i in range(m):
    p = int(input())
    
    for j in range(n):
        if ans[j] < p:
            ans[j] = p
            break

for i in ans:
    print(i)
```

This program will crash when it encounters the input `2 4 4`. The reason for this is that the input format is incorrect. The input should be three integers separated by spaces, but this input only has two integers.

### Incorrect output format

```
# Problem: Ithea Plays With Chtholly
# Author: Daniil Oleynik

n, m, c = map(int, input().split())
ans = []

for i in range(m):
    p = int(input())
    
    for j in range(n):
        if ans[j] < p:
            ans[j] = p
            break

for i in ans:
    print(i, end=" ")
```

This program will produce incorrect output when it encounters the input `2 4 4`. The reason for this is that the output format is incorrect. The output should be one integer per line, but this program prints all of the integers on the same line.

### Off-by-one errors

```
# Problem: Ithea Plays With Chtholly
# Author: Daniil Oleynik

n, m, c = map(int, input().split())
ans = []

for i in range(m):
    p = int(input())
    
    for j in range(n):
        if ans[j] < p:
            ans[j + 1] = p
            break

for i in ans:
    print(i)
```

This program will produce incorrect output when it encounters the input `2 4 4`. The reason for this is that the program is using an off-by-one error when it is updating the array `ans`. The program should be updating the element at index `j` with the value of `p`, but it is instead updating the element at index `j + 1`.

### Incorrect logic

```
# Problem: Ithea Plays With Chtholly
# Author: Daniil Oleynik

n, m, c = map(int, input().split())
ans = []

for i in range(m):
    p = int(input())
    
    for j in range(n):
        if ans[j] < p:
            ans[j] = p
            break

print(ans[n - 1])
```

This program will produce incorrect output when it encounters the input `2 4 4`. The reason for this is that the program is using incorrect logic to determine the winning sheet. The program should be choosing the sheet with the smallest number, but it is instead choosing the sheet with the largest number.

### Memory leaks

```
# Problem: Ithea Plays With Chtholly
# Author: Daniil Oleynik

n, m, c = map(int, input().split())
ans = []

for i in range(m):
    p = int(input())
    
    for j in range(n):
        if ans[j] < p:
            ans[j] = p
            break

print(ans[n - 1])

del ans
```

This program will leak memory when it encounters the input `2 4 4`. The reason for this is that the program is not freeing the memory that is allocated for the array `ans`. This can cause the program to run out of memory and crash.
CODEFORCES 917_C. Pollywog
**Incorrect understanding of the problem**

```
1 2 10 0
1 2
```

**Incorrect implementation of the algorithm**

```
2 3 10 2
1 2 3
5 -10
6 1000
```

**Incorrect testing**

```
3 4 100 0
1 2 3 4
50 100 150 200
```

**Incorrect debugging**

```
3 4 100 0
1 2 3 4
50 100 150 200
```

**Incorrect submission**

```
2 3 10 2
1 2 3
5 -10
6 1000
```
CODEFORCES 93_C. Azembler
```
255
```
CODEFORCES 967_A. Mind the Gap
```
6 60
0 0
1 20
3 21
5 0
19 30
23 40
```
```
16 50
0 30
1 20
3 0
4 30
6 10
7 50
9 30
11 10
12 50
14 30
16 10
17 50
19 30
21 10
22 50
23 59
```
```
3 17
0 30
1 0
12 0
```
```
1 1
```
```
0 0
```
CODEFORCES 993_A. Two Squares
```
#Test case 1: Incorrect input format

0 0 6 0 6 6 0 6
1 3 3 5 5 3 3 1

#Test case 2: Incorrect output format

0 0 6 0 6 6 0 6
1 3 3 5 5 3 3 1
Yes

#Test case 3: Incorrect calculation of intersection points

0 0 6 0 6 6 0 6
1 3 3 5 5 3 3 1
No

#Test case 4: Incorrect handling of degenerate cases

0 0 6 0 6 6 0 6
1 3 3 5 5 3 3 1
Yes

#Test case 5: Incorrect implementation of the algorithm

0 0 6 0 6 6 0 6
1 3 3 5 5 3 3 1
Yes

#Test case 6: Incorrect error handling

0 0 6 0 6 6 0 6
1 3 3 5 5 3 3 1
```
HACKEREARTH ashish-and-binary-matrix-1
```
1
3 3
101
000
100
```
HACKEREARTH chesters-revenge-4
1. ```
5
2 10
3 3
5 2
2 7
100 1000
```
2. ```
2 10
3 3
5 2
2 7
100 1000
```
3. ```
2 10
3 3
5 2
2 7
100 1000
```
4. ```
2 10
3 3
5 2
2 7
100 1000
```
5. ```
2 10
3 3
5 2
2 7
100 1000
```
HACKEREARTH dual-prime
1
10
111
121
HACKEREARTH gudi-and-the-magical-orbs-july-easy
```
1
3 3 7
2 3 1
6 1 9
```
HACKEREARTH little-shino-and-coins-3
```
1
a
```
```
3
aaa
```
```
5
abcaa
```
```
3
aa
```
```
2
ab
```
```
2
zz
```
```
26
abcdefghijklmnopqrstuvwxyz
```
```
26
zabcdefghijklmnopqrstuvwxyz
```
HACKEREARTH mystery
1
5 4 3
2
5 3 2
1 1 1
HACKEREARTH prime-sums
```
1
10
100
1000
10000
100000
1000000
4000000
```
HACKEREARTH sansas-escape
10
1 2 3 4 5 6 24 8 9 10
2
2 4
0 2
HACKEREARTH sureshs-array-3
```
1
5
5 3 7 1 2
```
HACKEREARTH where-have-the-vowels-gone-pledge-easy
1
a
ATCODER p02627 AtCoder Beginner Contest 171 - Î±lphabet
```
A

a

Z

z

!

0

```
ATCODER p02758 AtCoder Beginner Contest 158 - Removing Robots
```
2
1 5
3 3
```

```
3
6 5
-1 10
3 3
```

```
4
7 10
-10 3
4 3
-4 3
```

```
20
-8 1
26 4
0 5
9 1
19 4
22 20
28 27
11 8
-3 20
-25 17
10 4
-18 27
24 28
-11 19
2 27
-2 18
-1 12
-24 29
31 29
29 7
```
ATCODER p02893 AtCoder Grand Contest 039 - Division by Two with Something
```
3
111
```

```
6
110101
```

```
30
001110011011011101010111011100
```
ATCODER p03028 M-SOLUTIONS Programming Contest - Random Tournament
```
3
0
10
```

```
6
0
11
111
1111
11001
```

```
3
11
10
11
```

```
10
11
10
10
10
10
10
10
10
10
```

```
3
0
0
0
```
ATCODER p03169 Educational DP Contest - Sushi
```
3
1 1 1
```
```
1
3
```
```
2
1 2
```
```
10
1 3 2 3 3 2 3 2 1 3
```
ATCODER p03314 AtCoder Regular Contest 100 - Colorful Sequences
```
3 2 1
1

4 2 2
1 2

7 4 5
1 2 3 1 2

5 4 3
1 1 1

10 3 5
1 1 2 3 3

25000 400 4
3 7 31 127

9954 310 12
267 193 278 294 6 63 86 166 157 193 168 43
```
ATCODER p03471 AtCoder Beginner Contest 085 - Otoshidama
```
1 10000
10 10000
20 196000
1000 1234000
2000 20000000
```
ATCODER p03633 AtCoder Beginner Contest 070 - Multiple Clocks
```
2
2
3
```

```
5
2
5
10
1000000000000000000
1000000000000000000
```

```
100
1000000000000000000
```

```
1
1000000000000000000
```

```
3
1000000000000000000
1000000000000000000
1000000000000000000
```

```
5
2
5
10
1000000000000000000
1000000000000000000
```

```
3
36000
36000
36000
```

```
2
1000000000000000000
1000000000000000000
```
ATCODER p03791 Mujin Programming Challenge 2017 - Robot Racing
```
2
1 2
```
```
3
2 3 4
```
```
3
4 6 8
```
```
8
1 2 3 5 7 11 13 17
```
```
13
4 6 8 9 10 12 14 15 16 18 20 21 22
```
ATCODER p03959 CODE FESTIVAL 2016 qual C - Two Alpinists
```
1
17
17
```

```
5
1 1 1 2 2
3 2 1 1 1
```

```
10
1 3776 3776 8848 8848 8848 8848 8848 8848 8848
8848 8848 8848 8848 8848 8848 8848 8848 3776 5
```

```
1
17
17
```
AIZU p00051 Differential II
1. **Incorrect input format**

```
1
99999999
```

2. **Incorrect output format**

```
1
12345678
```

3. **Incorrect calculation of the difference**

```
1
100000000
```

4. **Incorrect handling of edge cases**

```
1
00000000
```

5. **Other bugs**

```
1
12345678
```
AIZU p00181 Bookshelf
0 0
AIZU p00337 Road Planning
5 5
0 0
1 1
3 0
3 2
0 2
1 2
2 3
2 4
3 4
1 5


5 6
0 2
3 0
2 2
1 0
4 1
2 3
3 5
1 3
2 4
2 3
3 5
3 7
6 7

AIZU p00528 Modern Mansion
3 2 1
1 2
AIZU p00695 Get a Rectangular Field
1
1 1 0 1 0
0 1 1 1 1
1 0 1 0 1
0 1 1 1 0
0 1 1 0 0

2
1 1 0 1 1
0 1 0 1 0
0 0 1 0 0
0 0 1 1 0
1 0 1 0 0

4
1 1 1 1 0
0 1 1 1 0
0 1 1 0 1
0 1 1 1 0
0 0 0 0 1
AIZU p00836 Sum of Consecutive prime Numbers
```
2
3
17
41
20
666
12
53
0
```
AIZU p00968 Digits Are Not Just Characters
```
10
X52Y
X
X5
X52
X52Y
X52Y6
32
ABC
XYZ
x51y
X8Y
X222
```
AIZU p01100 Gift Exchange Party
3 3
1 2
2 3
1 3
4 3
1 2
1 3
1 4
4 6
1 2
1 3
1 4
2 3
3 4
2 4
0 0
AIZU p01237 Life Game
**Incorrect input format**

```
3 3 1
1 0 a
0 0 0 0
0 0 0 0 0
0 0 0 0
0 0 1
```

**Incorrect calculation**

```
3 3 2
1 0 0
0 0 0 0
0 0 0 0 0
0 0 0 0
0 0 1
1 0 0
```

**Memory leak**

```
3 3 2
1 0 0
0 0 0 0
0 0 0 0 0
0 0 0 0
0 0 1
```

**Synchronization issues**

```
3 3 2
1 0 0
0 0 0 0
0 0 0 0 0
0 0 0 0
0 0 1
```

**Security vulnerabilities**

```
3 3 2
1 0 0
0 0 0 0
0 0 0 0 0
0 0 0 0
0 0 1
```
AIZU p01399 Problem B
2
4
5
6
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
AIZU p01552 YAML
```
.a.b
a:
  b: b
```
AIZU p01708 Points and Lines
((0,0)@(1,1))@((4,1)@(2,5))
((0,0)@(3,1))@((1,-3)@(2,-1))
(0,0)@(1,1)@(4,1)
(0,0)@((1,1)@(4,1))
(((0,0)@((10,20)@(((30,40))))))
((0,0)@(3,1))@((1,-3)@(2,-1))@(100,-100)@(100,100)
#
AIZU p01853 Lie with Mean Value
1. Incorrect input format
```
3 100
```
2. Incorrect calculation of the average and median values
```
3 100
```
3. Incorrect output format
```
3 100
```
4. Other bugs
```
3 100
```
AIZU p01988 NINJA GAME
```
8
1 1 2 2
0 2
0 0
2 0
2 1
3 1
3 3
1 3
1 2
12
-9 5 9 -9
0 0
0 -13
3 -13
3 -10
10 -10
10 10
-1 10
-1 13
-4 13
-4 10
-10 10
-10 0
12
3 57 53 2
0 0
64 0
64 18
47 18
47 39
64 39
64 60
0 60
0 44
33 44
33 30
0 30
0
```
AIZU p02134 Move on Ice
```
# 02134 Move on Ice
# https://atcoder.jp/contests/aizu0213/tasks/aizu0213_b

def main():
    sx, sy = map(int, input().split())
    tx, ty = map(int, input().split())
    n = int(input())
    xs = []
    ys = []
    for i in range(n):
        x, y = map(int, input().split())
        xs.append(x)
        ys.append(y)

    ds = []
    for i in range(4):
        ds.append((1, 0))
        ds.append((0, 1))
        ds.append((-1, 0))
        ds.append((0, -1))

    visited = [[False] * 10 ** 6 for _ in range(10 ** 6)]
    que = [(sx, sy, 0)]
    visited[sx][sy] = True
    while que:
        x, y, cnt = que.pop(0)
        if x == tx and y == ty:
            print(cnt)
            break
        for dx, dy in ds:
            nx = x + dx
            ny = y + dy
            if 0 <= nx < 10 ** 6 and 0 <= ny < 10 ** 6 and visited[nx][ny] == False:
                if nx in xs and ny in ys:
                    que.append((nx, ny, cnt + 1))
                    visited[nx][ny] = True
                else:
                    que.append((nx, ny, cnt))
                    visited[nx][ny] = True

if __name__ == "__main__":
    main()
```
AIZU p02275 Counting Sort
**Incorrectly implementing the counting sort algorithm.**

```
n = int(input())
a = list(map(int, input().split()))
c = [0] * 10001
for i in a:
    c[i] += 1
for i in range(1, 10001):
    c[i] += c[i - 1]
for i in range(n - 1, -1, -1):
    print(c[a[i]] - 1, end=" ")
print(c[a[0]])
```

**Using an incorrect data type for the counting array.**

```
n = int(input())
a = list(map(int, input().split()))
c = [0] * 2
for i in a:
    c[i] += 1
for i in range(1, 2):
    c[i] += c[i - 1]
for i in range(n - 1, -1, -1):
    print(c[a[i]] - 1, end=" ")
print(c[a[0]])
```

**Not handling duplicate values correctly.**

```
n = int(input())
a = list(map(int, input().split()))
c = [0] * 10001
for i in a:
    c[i] += 1
for i in range(1, 10001):
    c[i] += c[i - 1]
for i in range(n - 1, -1, -1):
    print(c[a[i]] - 1, end=" ")
print(c[a[0]])
```

**Not using the counting array correctly.**

```
n = int(input())
a = list(map(int, input().split()))
c = [0] * 10001
for i in a:
    c[i] += 1
for i in range(1, 10001):
    c[i] += c[i - 1]
for i in range(n - 1, -1, -1):
    print(c[a[i]] - 1, end=" ")
print(c[a[0]])
```
AIZU p02422 Transformation
```
input1 = 'abcde'
input2 = 3
input3 = ['replace 1 3 xyz', 'reverse 0 2', 'print 1 4']

input4 = 'xyz'
input5 = 3
input6 = ['print 0 2', 'replace 0 2 abc', 'print 0 2']
```